import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Product/Epics/Platform SDK & Agent CLI" />

# Epic: Platform SDK & Agent CLI

**Status:** In progress (Phase 1 CLI slice started)
**See also:** [Copilot V2+](?path=/docs/product-epics-copilot-v2--docs), [Architecture](?path=/docs/engineering-architecture--docs)

**Immediate goal (Phase 1):** Replace the current 3 Copilot tool calls with a single `tay_cli` tool using an in-place, test-driven refactor. First lock in current behavior, then switch execution path.

## Collaboration Goal (Dogfooding)

The CLI is only "sufficient" when Codex and Claude Code can collaborate with a human operator to
plan, schedule, and execute improvement/development work directly inside a self-hosted Senticor
Project workspace.

Target outcome for internal dogfooding:

- Senticor Project is the operational workspace for its own product development
- CLI-first collaboration loop works for human + agent pair programming/project management
- Planning/scheduling/delivery artifacts are captured in-product as items and references

Definition of "sufficient for collaboration":

- Codex and Claude Code can list projects, inspect work, and create/triage/update items using only `tay_cli`
- Codex and Claude Code can create/update epic-tracking todos in existing self-hosted projects
- Human + agent collaboration can run end-to-end in Senticor Project for planning, scheduling, and execution
- Decisions, plans, and references are stored in Senticor Project as the primary system of record
- Typical loop (plan -> propose -> confirm -> apply -> verify) runs reliably through CLI + UI

## Context

Copilot's tool logic is duplicated across two languages — Python `jsonld_builders.py` mirrors the
TypeScript `item-serializer.ts`, Python `backend_client.py` mirrors `api-client.ts`. Adding a new
Copilot capability requires changes in 4–5 Python files plus the system prompt. There is no client-side
validation layer (JSON-LD is built and POSTed with only backend enforcement), and no integration
path for 3rd parties.

**Problem:** Every new Copilot tool means more Python code that duplicates existing TypeScript logic.
Validation rules live only on the server. External clients have no SDK.

**Outcome:** A TypeScript `@project/core` package with CLI commands, serializers, API client,
and validation — used by the frontend, Copilot (as a single tool), and 3rd party integrations.

---

## Architecture

### Package Structure

```txt
packages/core/
├── cli/                  # CLI entry point + subcommands
│   ├── index.ts          # main CLI runner
│   ├── items.ts          # items list|get|create|update|triage
│   ├── orgs.ts           # orgs list|get|append-log|update-doc
│   └── projects.ts       # projects list|get|create
├── serializers/          # JSON-LD ↔ domain model (extracted from item-serializer.ts)
├── client/               # API client (extracted from api-client.ts)
└── validation/
    ├── shacl/            # SHACL shapes for JSON-LD constraints
    └── cel/              # CEL rules for business logic
```

### Isomorphic Design

The package runs in three environments:

| Environment              | Runtime            | Entry point                                            |
| ------------------------ | ------------------ | ------------------------------------------------------ |
| **Frontend** (React app) | Browser            | `import { fromJsonLd, toJsonLd } from "@project/core"` |
| **Copilot** (agent tool) | Node.js subprocess | `npx tay items list --bucket=reference`                |
| **3rd party**            | Browser or Node.js | `npm install @project/core`                            |

The frontend's `src/lib/item-serializer.ts` and `src/lib/api-client.ts` become thin re-exports from
the core package. No more maintaining two implementations.

---

## Feature 1: CLI for Copilot (Single Tool)

### Current State: 3 Tool Calls + Python Dispatch

```txt
tay.py             → 3 tool definitions (create_project_with_actions, create_action, create_reference)
tool_executor.py   → dispatch switch + execution logic
jsonld_builders.py → Python JSON-LD builders (duplicates item-serializer.ts)
backend_client.py  → Python API client (duplicates api-client.ts)
tay_system.j2      → documents each tool individually
```

Adding a new tool still requires cross-file Python changes and prompt updates.

### Refactor Strategy: In-place + Test-driven

Before replacing tools, prove baseline behavior is correct and stable. Then refactor in place.

1. Baseline tests pass for current 3-tool setup (`create_project_with_actions`, `create_action`, `create_reference`)
2. Add/expand contract tests around tool schema + execution payloads
3. Introduce CLI commands that produce the same output contracts
4. Swap Haystack tool surface to one `tay_cli` tool
5. Keep approval-card flow unchanged for writes
6. Remove legacy per-tool dispatch only after parity is proven

### Target State: 1 Tool + CLI

Copilot gets a single tool in its Haystack tool schema:

```json
{
  "name": "tay_cli",
  "description": "Execute a COPILOT CLI command. Run `help` for available commands.",
  "parameters": {
    "argv": {
      "type": "array",
      "items": { "type": "string" },
      "description": "CLI arguments without shell quoting, e.g. [\"items\", \"list\", \"--summary\", \"--json\"]"
    }
  }
}
```

The Python Haystack orchestrator (`agents/tay.py`) stays — it handles LLM interaction, conversation
history, and streaming. Only the tool executor changes: instead of dispatching to Python functions,
it calls the TypeScript CLI via subprocess.

### Agent Compatibility Contract (Codex, Claude Code, and other tool callers)

To make `tay` usable like `gh`/`glab`, the CLI contract must be deterministic, shell-free, and
machine-first.

#### Tool Interface (No Shell String)

Agents call `tay_cli` with `argv: string[]` and execute `["tay", ...argv]` directly. Raw shell
strings are out of scope because quoting/parsing differences create brittle behavior across runtimes.

#### Machine Output Contract (`--json`)

When `--json` is present, stdout must contain exactly one JSON object. Human-readable logs and
warnings go to stderr only.

Read responses:

```json
{
  "schema_version": "tay.v1",
  "ok": true,
  "data": {},
  "meta": { "request_id": "req_123", "duration_ms": 42 }
}
```

Write proposals:

```json
{
  "schema_version": "tay.v1",
  "ok": true,
  "mode": "proposal",
  "proposal": {
    "id": "prp_123",
    "operation": "items.create",
    "preview": {}
  }
}
```

Errors:

```json
{
  "schema_version": "tay.v1",
  "ok": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "bucket must be one of inbox,next,waiting,someday,scheduled,completed",
    "details": [{ "field": "bucket", "rule": "enum" }],
    "retryable": false
  }
}
```

#### Auth + Non-Interactive Behavior

- Support token auth via both `tay auth login --with-token` and `TAY_TOKEN`
- Support `TAY_HOST` for environment targeting
- Support `--non-interactive`, `--yes`, `--no-color`, `--json`
- In non-interactive mode, missing auth/input exits immediately with a non-zero code (no prompts)

#### Exit Codes

| Exit code | Meaning                          |
| --------- | -------------------------------- |
| `0`       | Success                          |
| `2`       | Usage/argument error             |
| `3`       | Authentication/authorization     |
| `4`       | Validation failed                |
| `5`       | Not found                        |
| `10`      | Conflict/precondition failed     |
| `20`      | Transient backend/network error  |

### Read vs Write Commands

| Type                         | Behavior                                                         | Examples                                                                                                  |
| ---------------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Read** (inline)            | Executes immediately, returns data to Copilot                    | `items list --bucket=reference --json`, `orgs get nueva-tierra --docs --json`                           |
| **Write** (proposal + apply) | Step 1 returns proposal JSON. Step 2 executes only after confirm | `items create --type=Action --name="File taxes" --bucket=next --propose --json`, `proposals apply <id> --yes --json` |

Write commands return proposal JSON that the frontend renders as the same approval card the user
already sees. The two-step "propose, user confirms, apply" pattern is unchanged.

### Example CLI Session (as Copilot would use it)

```bash
# Discover workspace
tay items list --summary --json

# Read an org's details
tay orgs get nueva-tierra --docs --json

# Read a specific document
tay items get urn:app:reference:abc123 --content --json

# Check auth/session status
tay auth status --json

# Propose creating a person (returns proposal JSON for approval UI)
tay items create --type=Person --name="Steuerberater Schmidt" \
  --org=nueva-tierra --role=accountant --email="schmidt@steuer.de" \
  --propose --json

# Apply only after explicit user confirmation
tay proposals apply prp_123 --yes --json
```

### System Prompt Change

```jinja2
## Werkzeug
Du hast ein einziges Werkzeug: `tay_cli`. Damit führst du Befehle aus.
Übergebe Befehle immer als `argv: string[]` (kein Shell-String).

### Agent-Regeln
- Für maschinenlesbare Antworten immer `--json` setzen.
- Keine interaktiven Prompts verwenden (`--non-interactive`, `--yes`).
- Schreibbefehle immer 2-stufig:
  1. Vorschlag mit `--propose --json`
  2. Nach Nutzerbestätigung `proposals apply <id> --yes --json`

### Lesen (sofort)
- `items list [--bucket=X] [--org=X] [--summary] --json` — Elemente auflisten
- `items get <id> [--content] --json` — Element lesen
- `orgs list --json` — Organisationen auflisten
- `orgs get <id> [--docs] --json` — Organisation mit Dokumenten lesen
- `projects list --json` — Projekte auflisten
- `projects get <id> [--items] --json` — Projekt mit Elementen lesen
- `auth status --json` — Auth-Status prüfen

### Schreiben (Nutzer muss bestätigen)
- `items create --type=<Type> --name="..." [--bucket=X] [--project=X] --propose --json`
- `items triage <id> --bucket=<target> --propose --json`
- `orgs append-log <org> --entry="..." --propose --json`
- `orgs update-doc <org> --doc=agent --content="..." --propose --json`
- `proposals apply <id> --yes --json`

Verwende `tay_cli help` für die vollständige Befehlsreferenz.
```

---

## Feature 2: SHACL Validation Shapes

[SHACL](https://www.w3.org/TR/shacl/) (Shapes Constraint Language) validates RDF graph shapes.
Since JSON-LD is valid RDF, SHACL is the natural validation standard for our data model.

### Example Shapes

```turtle
# Every Action must have a name and a valid bucket
app:ActionShape a sh:NodeShape ;
  sh:targetClass schema:Action ;
  sh:property [
    sh:path schema:name ;
    sh:minCount 1 ;
    sh:datatype xsd:string
  ] ;
  sh:property [
    sh:path app:bucket ;
    sh:minCount 1 ;
    sh:in ("inbox" "next" "waiting" "someday" "scheduled" "completed")
  ] .

# A Person must have a name and an orgRef
app:PersonShape a sh:NodeShape ;
  sh:targetClass schema:Person ;
  sh:property [ sh:path schema:name ; sh:minCount 1 ] ;
  sh:property [ sh:path app:orgRef ; sh:minCount 1 ] ;
  sh:property [
    sh:path app:orgRole ;
    sh:in ("member" "founder" "accountant" "advisor" "interest")
  ] .
```

### Validation Libraries

JavaScript SHACL validators that run in Node.js and browser:

- [`rdf-validate-shacl`](https://github.com/zazuko/rdf-validate-shacl)
- [`shacl-engine`](https://github.com/rdf-ext/shacl-engine)

Shapes are defined once in `.ttl` files within `packages/core/validation/shacl/` and used by both
the CLI (client-side) and the backend (server-side).

---

## Feature 3: CEL Business Rules

[CEL](https://cel.dev/) (Common Expression Language) handles business rules that go beyond graph
shape constraints — transition rules, field immutability, access control.

### Example Rules

```cel
// Inbox items can only triage to these target buckets
item.bucket == "inbox" && target_bucket in ["next", "waiting", "someday", "scheduled", "reference"]

// LOG.md is append-only — content can only grow
new_content.startsWith(old_content)

// Archived items cannot be modified
!(item.bucket == "completed" && operation == "update")

// Only agents can write to AGENT.md
item.orgDocType == "agent" && caller.role in ["agent", "admin"]
```

### CEL Libraries

- [`cel-js`](https://github.com/nicholasgasior/cel-js) — JavaScript CEL implementation
- Rules defined as JSON in `packages/core/validation/cel/rules.json`
- Same rules evaluated client-side (fail fast) and server-side (enforce)

---

## Fail-Fast Validation Pattern

```txt
Client (browser / CLI / Copilot)              Server (backend)
────────────────────────────              ──────────────────
1. Build JSON-LD (serializers)
2. SHACL validate (fail fast)  ────────→  4. SHACL validate (enforce)
3. CEL rules check (fail fast) ────────→  5. CEL rules check (enforce)
                                          6. Persist to PostgreSQL
```

Client catches errors instantly (no roundtrip). Server enforces at the trust boundary (never trusts
client validation alone). Same shapes and rules in both places — single source of truth in the core
package.

---

## Why TypeScript

| Consideration           | TypeScript                                             | Python                              |
| ----------------------- | ------------------------------------------------------ | ----------------------------------- |
| Frontend canonical code | Already exists (`item-serializer.ts`, `api-client.ts`) | Would be a copy                     |
| Browser-compatible      | Yes — 3rd party web clients validate in-browser        | No                                  |
| SHACL libraries         | `rdf-validate-shacl`, `shacl-engine`                   | `pyshacl` (server-only)             |
| CEL libraries           | `cel-js`                                               | `cel-python` (server-only)          |
| Copilot integration     | subprocess or HTTP from Python Haystack                | Native but duplicates frontend code |
| Single codebase         | One implementation, three consumers                    | Two implementations that drift      |

---

## Why CLI over Query Languages

[NeurIPS'24 benchmark](https://medium.com/data-science/can-llms-talk-sql-sparql-cypher-and-mongodb-query-language-mql-equally-well-a478f64cc769)
comparing LLM accuracy across query languages:

| Approach                  | Zero-shot accuracy                     |
| ------------------------- | -------------------------------------- |
| **Tool/function calling** | ~95%+ (models are fine-tuned for this) |
| SQL                       | ~47%                                   |
| Cypher (Neo4j)            | ~34%                                   |
| SPARQL                    | &lt;4%                                 |

Named CLI commands are structured tool calls with discoverability (`--help`) and composability.
LLMs are explicitly trained for tool use — fighting that with query languages is working against the
grain.

If relationship traversal ever outgrows named commands (50+ entities, complex cross-org joins), a
`tay graph query "..."` subcommand can be added. But JSON-LD already is valid RDF — the data is
ready, the need just isn't there yet.

---

## Implementation Phases

### Phase 1: Baseline + Extract & CLI (enables Copilot)

1. Verify current agent flow is green (`agents/tests/test_tay.py`, `agents/tests/test_tool_executor.py`, `agents/tests/test_jsonld_builders.py`, `agents/tests/test_backend_client.py`)
2. Add parity tests that lock tool-call schema, JSON output contracts (`tay.v1`), and exit codes
3. Create `packages/core/` with TypeScript project
4. Move `item-serializer.ts` and `api-client.ts` to core, re-export from frontend
5. Add CLI entry point with subcommands (`items`, `orgs`, `projects`, `auth`, `proposals`) plus compatibility commands for current create flows
6. Wire as single `tay_cli` tool in Haystack using `argv` arrays, replace Python tool executor dispatch with CLI subprocess call
7. Update system prompt to document CLI commands and proposal/apply semantics
8. Remove old tool-call definitions only after parity tests pass

### Phase 2: SHACL Shapes

1. Define SHACL shapes for each `@type` (`Action`, `Person`, `Project`, `CreativeWork`, `DigitalDocument`)
2. Add `validate()` call to CLI write commands (fail fast)
3. Add server-side SHACL validation in backend item creation/update endpoints

### Phase 3: CEL Rules

1. Define business rules as CEL expressions
2. Integrate CEL evaluation into CLI and backend
3. Bucket transition rules, field immutability, access control

### Phase 4: Future

- Graph query subcommand if/when relationship traversal outgrows named commands
- FRBR/LexCEL ontology work drives this naturally
- JSON-LD remains RDF-compatible — Fuseki or Apache AGE can be added as a projection

---

## Files to Modify/Create

| Layer    | File                                   | Change                                                     |
| -------- | -------------------------------------- | ---------------------------------------------------------- |
| Core     | NEW: `packages/core/package.json`      | Package setup, TypeScript config                           |
| Core     | NEW: `packages/core/cli/index.ts`      | CLI entry point                                            |
| Core     | NEW: `packages/core/cli/items.ts`      | Items subcommands                                          |
| Core     | NEW: `packages/core/cli/orgs.ts`       | Orgs subcommands                                           |
| Core     | NEW: `packages/core/cli/projects.ts`   | Projects subcommands                                       |
| Core     | NEW: `packages/core/cli/auth.ts`       | Auth commands (`login`, `status`)                         |
| Core     | NEW: `packages/core/cli/proposals.ts`  | Proposal/apply workflow commands                           |
| Core     | NEW: `packages/core/cli/output.ts`     | Stable `tay.v1` JSON envelope + error mapping             |
| Core     | `packages/core/serializers/`           | Extracted from `item-serializer.ts`                        |
| Core     | `packages/core/client/`                | Extracted from `api-client.ts`                             |
| Core     | NEW: `packages/core/validation/shacl/` | SHACL shape definitions (`.ttl`)                           |
| Core     | NEW: `packages/core/validation/cel/`   | CEL rule definitions                                       |
| Frontend | `frontend/src/lib/item-serializer.ts`  | Re-export from `@project/core`                             |
| Frontend | `frontend/src/lib/api-client.ts`       | Re-export from `@project/core`                             |
| Agents   | `agents/tay.py`                        | Replace 3 tools with single `tay_cli` tool                 |
| Agents   | `agents/tool_executor.py`              | Replace per-tool dispatch with TS CLI subprocess execution |
| Agents   | `agents/jsonld_builders.py`            | Deprecated (replaced by core serializers)                  |
| Agents   | `agents/backend_client.py`             | Deprecated (replaced by core client)                       |
| Agents   | `agents/prompts/de/tay_system.j2`      | CLI command documentation                                  |
| Monorepo | `package.json`                         | Workspace config for `packages/core`                       |
| Monorepo | `tsconfig.json`                        | Project reference to `packages/core`                       |

---

## Verification

1. Baseline agents tests (pre-refactor): `cd agents && uv run python -m pytest tests/`
2. Core: `cd packages/core && npm test` (serializer round-trips, CLI command tests, SHACL validation)
3. Frontend types: `cd frontend && npx tsc -b --noEmit`
4. Frontend unit: `cd frontend && CI=1 npx vitest run --project=unit`
5. Frontend storybook: `cd frontend && STORYBOOK_TESTS=1 CI=1 npx vitest run --project=storybook`
6. Agents (post-refactor parity): `cd agents && uv run python -m pytest tests/` (CLI subprocess integration + compatibility expectations)
7. CLI contract tests: `npx tay items list --summary --json` returns valid `tay.v1` envelope (stdout-only JSON, non-zero errors on stderr)
8. CLI write flow tests: `npx tay items create --type=Action --name="File taxes" --bucket=next --propose --json` returns proposal id, then `npx tay proposals apply <id> --yes --json` executes
9. CLI auth/non-interactive tests: missing token in CI mode fails with exit code `3` and structured error JSON
10. Manual E2E: Start dev stack → open Copilot chat → ask "Was gibt es im Workspace?" → Copilot calls `tay_cli(argv=["items","list","--summary","--json"])` → returns workspace overview
11. Dogfooding E2E: Using only `tay_cli`, create/update epic todos and references in active projects, then confirm state is visible in Senticor Project UI
12. Collaboration sufficiency check: Codex/Claude Code + human can run weekly planning/scheduling/review directly in self-hosted Senticor Project with no external tracker dependency
