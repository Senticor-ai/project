import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Product/Completed Epics/Platform SDK & Agent CLI" />

# Epic: Platform SDK & Agent CLI

**Status:** Closed
**Closed on:** February 25, 2026
**See also:** [Copilot V2+](?path=/docs/product-completed-epics-copilot-v2--docs), [Architecture](?path=/docs/engineering-architecture--docs)

**Current goal:** Make Senticor Copilot CLI sufficient for day-to-day human + Codex + Claude Code collaboration in self-hosted Senticor Project, with Senticor Project as the primary tracker/system of record.

**Command name:** Use `senticor-copilot` (primary) or `copilot` (short alias).

## Collaboration Goal (Dogfooding)

The CLI is only "sufficient" when Codex and Claude Code can collaborate with a human operator to
plan, schedule, and execute improvement/development work directly inside a self-hosted Senticor
Project workspace.

Target outcome for internal dogfooding:

- Senticor Project is the operational workspace for its own product development
- CLI-first collaboration loop works for human + agent pair programming/project management
- Planning/scheduling/delivery artifacts are captured in-product as items and references

Definition of "sufficient for collaboration":

- Codex and Claude Code can list projects, inspect work, and create/triage/update items using only `copilot_cli`
- Codex and Claude Code can create/update epic-tracking todos in existing self-hosted projects
- Human + agent collaboration can run end-to-end in Senticor Project for planning, scheduling, and execution
- Decisions, plans, and references are stored in Senticor Project as the primary system of record
- Typical loop (plan -> propose -> confirm -> apply -> verify) runs reliably through CLI + UI

## Context

Copilot's tool logic is duplicated across two languages — Python `jsonld_builders.py` mirrors the
TypeScript `item-serializer.ts`, Python `backend_client.py` mirrors `api-client.ts`. Adding a new
Copilot capability requires changes in 4–5 Python files plus the system prompt. There is no client-side
validation layer (JSON-LD is built and POSTed with only backend enforcement), and no integration
path for 3rd parties.

**Problem:** Every new Copilot tool means more Python code that duplicates existing TypeScript logic.
Validation rules live only on the server. External clients have no SDK.

**Outcome:** A TypeScript `@project/core` package with CLI commands, serializers, API client,
and validation — used by the frontend, Copilot (as a single tool), and 3rd party integrations.

---

## Architecture

### Package Structure

```txt
packages/core/
├── cli/                  # CLI entry point + subcommands
│   ├── index.ts          # main CLI runner
│   ├── items.ts          # items list|get|create|triage
│   ├── orgs.ts           # orgs list|get
│   └── projects.ts       # projects list|get|create
├── serializers/          # JSON-LD ↔ domain model (extracted from item-serializer.ts)
├── client/               # API client (extracted from api-client.ts)
└── validation/
    ├── shacl/            # SHACL shapes for JSON-LD constraints
    └── cel/              # CEL rules for business logic
```

### Isomorphic Design

The package runs in three environments:

| Environment              | Runtime            | Entry point                                            |
| ------------------------ | ------------------ | ------------------------------------------------------ |
| **Frontend** (React app) | Browser            | `import { fromJsonLd, toJsonLd } from "@project/core"` |
| **Copilot** (agent tool) | Node.js subprocess | `npx senticor-copilot items list --bucket=reference`   |
| **3rd party**            | Browser or Node.js | `npm install @project/core`                            |

The frontend's `src/lib/item-serializer.ts` and `src/lib/api-client.ts` become thin re-exports from
the core package. No more maintaining two implementations.

---

## Feature 1: CLI for Copilot (Single Tool)

### Current State: 3 Tool Calls + Python Dispatch

```txt
agents/copilot.py      → 3 tool definitions (create_project_with_actions, create_action, create_reference)
tool_executor.py   → dispatch switch + execution logic
jsonld_builders.py → Python JSON-LD builders (duplicates item-serializer.ts)
backend_client.py  → Python API client (duplicates api-client.ts)
copilot_system.j2      → documents each tool individually
```

Adding a new tool still requires cross-file Python changes and prompt updates.

### Refactor Strategy: In-place + Test-driven

Before replacing tools, prove baseline behavior is correct and stable. Then refactor in place.

1. Baseline tests pass for current 3-tool setup (`create_project_with_actions`, `create_action`, `create_reference`)
2. Add/expand contract tests around tool schema + execution payloads
3. Introduce CLI commands that produce the same output contracts
4. Swap Haystack tool surface to one `copilot_cli` tool
5. Keep approval-card flow unchanged for writes
6. Remove legacy per-tool dispatch only after parity is proven

### Target State: 1 Tool + CLI

Copilot gets a single tool in its Haystack tool schema:

```json
{
  "name": "copilot_cli",
  "description": "Execute a COPILOT CLI command. Run `help` for available commands.",
  "parameters": {
    "argv": {
      "type": "array",
      "items": { "type": "string" },
      "description": "CLI arguments without shell quoting, e.g. [\"items\", \"list\", \"--summary\", \"--json\"]"
    }
  }
}
```

The Python Haystack orchestrator (`agents/copilot.py`) stays — it handles LLM interaction, conversation
history, and streaming. Only the tool executor changes: instead of dispatching to Python functions,
it calls the TypeScript CLI via subprocess.

### Agent Compatibility Contract (Codex, Claude Code, and other tool callers)

To make Senticor Copilot CLI usable like `gh`/`glab`, the contract must be deterministic, shell-free, and
machine-first.

#### Tool Interface (No Shell String)

Agents call `copilot_cli` with `argv: string[]` and execute `["senticor-copilot", ...argv]` directly. Raw shell
strings are out of scope because quoting/parsing differences create brittle behavior across runtimes.

#### Machine Output Contract (`--json`)

When `--json` is present, stdout must contain exactly one JSON object. Human-readable logs and
warnings go to stderr only.

Read responses:

```json
{
  "schema_version": "copilot.v1",
  "ok": true,
  "data": {},
  "meta": { "request_id": "req_123", "duration_ms": 42 }
}
```

Write proposals:

```json
{
  "schema_version": "copilot.v1",
  "ok": true,
  "mode": "proposal",
  "proposal": {
    "id": "prp_123",
    "operation": "items.create",
    "preview": {}
  }
}
```

Errors:

```json
{
  "schema_version": "copilot.v1",
  "ok": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "bucket must be one of inbox,next,waiting,someday,calendar,reference,completed",
    "details": [{ "field": "bucket", "rule": "enum" }],
    "retryable": false
  }
}
```

#### Auth + Non-Interactive Behavior

- Support token auth via `COPILOT_TOKEN` for non-interactive agent execution
- Support `COPILOT_HOST` for environment targeting
- Support `--non-interactive`, `--yes`, `--no-color`, `--json`
- Each user has a default self-org; if `--org-id` is omitted, CLI resolves org from session/user context
- In non-interactive mode, missing auth/input exits immediately with a non-zero code (no prompts)

#### Exit Codes

| Exit code | Meaning                         |
| --------- | ------------------------------- |
| `0`       | Success                         |
| `2`       | Usage/argument error            |
| `3`       | Authentication/authorization    |
| `4`       | Validation failed               |
| `5`       | Not found                       |
| `10`      | Conflict/precondition failed    |
| `20`      | Transient backend/network error |

### Read vs Write Commands

| Type                         | Behavior                                                         | Examples                                                                                                                                                                                                            |
| ---------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Read** (inline)            | Executes immediately, returns data to Copilot                    | `items list --bucket=reference --json`, `orgs get nueva-tierra --docs --json`                                                                                                                                       |
| **Write** (proposal + apply) | Step 1 returns proposal JSON. Step 2 executes only after confirm | `projects create --name="Senticor Project" --description="Use Senticor to build Senticor" --propose --json`, `items create --type=Action --name="File taxes" --bucket=next --project=<project_id> --propose --json` |

In direct CLI usage, write commands support a two-step "propose, user confirms, apply" flow that
returns proposal JSON.

For chat-driven tool execution, user confirmation already happens before execution (approval card),
so the agent can safely call write commands with `--apply --yes`.

### Example CLI Session (as Copilot would use it)

```bash
# Discover workspace
senticor-copilot items list --summary --json

# Read an org's details
senticor-copilot orgs get nueva-tierra --docs --json

# Read a specific document
senticor-copilot items get urn:app:org:7c43cef1-7e20-4784-9d56-9f9adc8baf1d:reference:abc123 --content --json

# Check auth/session status
senticor-copilot auth status --json

# Propose creating a project first
senticor-copilot projects create --name="Senticor Project" \
  --description="Use Senticor to plan and ship Senticor" --propose --json

# Use org-scoped project IDs (schema-style URN with org segment)
PROJECT_ID='urn:app:org:<org-id>:project:<uuid>'

# Propose creating a person (returns proposal JSON for approval UI)
senticor-copilot items create --type=Person --name="Steuerberater Schmidt" \
  --org=nueva-tierra --role=accountant --email="schmidt@steuer.de" \
  --propose --json

# Apply only after explicit user confirmation
senticor-copilot proposals apply prp_123 --yes --json
```

### System Prompt Change

```jinja2
## Werkzeug
Du hast ein einziges Werkzeug: `copilot_cli`. Damit führst du Befehle aus.
Übergebe Befehle immer als `argv: string[]` (kein Shell-String).

### Agent-Regeln
- Für maschinenlesbare Antworten immer `--json` setzen.
- Keine interaktiven Prompts verwenden (`--non-interactive`, `--yes`).
- Schreibbefehle mit `--apply` ausführen; Nutzerbestätigung passiert vorab über die Approval-Karte.

### Lesen (sofort)
- `items list [--bucket=X] [--org=X] [--summary] --json` — Elemente auflisten
- `items get <id> [--content] --json` — Element lesen
- `orgs list --json` — Organisationen auflisten
- `orgs get <id> [--docs] --json` — Organisation mit Dokumenten lesen
- `projects list --json` — Projekte auflisten
- `projects get <id> [--items] --json` — Projekt mit Elementen lesen
- `projects actions list --project=<id> [--status=<status>] [--due-before=<iso>] [--due-after=<iso>] --json` — Projektaktionen lesen
- `projects actions get --project=<id> --action=<id> [--history] [--comments] --json` — Aktion lesen
- `auth status --json` — Auth-Status prüfen

### Schreiben (Nutzer muss bestätigen)
- `items create --type=<Type> --name="..." [--bucket=X] [--project=X] --apply --json`
- `items triage <id> --bucket=<target> --apply --json`
- `projects create --name="..." [--description="..."] --apply --json`
- `projects actions create --project=<id> --name="..." [--due=<iso>] --apply --json`
- `projects actions update --project=<id> --action=<id> [...] --apply --json`
- `projects actions transition --project=<id> --action=<id> --to=<status> --apply --json`

### Wochenreview-Playbook
- Nutze Senticor als einzige Quelle (kein externer Tracker).
- Erstelle zuerst Review aus `items list --json` + `items list --bucket completed --json`.
- Gib strukturierte Auswertung: erstellt/aktualisiert, abgeschlossen, offene Risiken.
- Schlage priorisierte kommende Woche vor.
- Bei Bedarf direkt Vorschläge erzeugen: Projekt anlegen, Mid-Week-Check im `calendar`-Bucket, Aktionen schließen/umtriagieren, Referenznotiz erstellen.

Verwende `copilot_cli help` für die vollständige Befehlsreferenz.
```

---

## Feature 2: SHACL Validation Shapes

[SHACL](https://www.w3.org/TR/shacl/) (Shapes Constraint Language) validates RDF graph shapes.
Since JSON-LD is valid RDF, SHACL is the natural validation standard for our data model.

### Example Shapes

```turtle
# Every Action must have a name and a valid bucket
app:ActionShape a sh:NodeShape ;
  sh:targetClass schema:Action ;
  sh:property [
    sh:path schema:name ;
    sh:minCount 1 ;
    sh:datatype xsd:string
  ] ;
  sh:property [
    sh:path app:bucket ;
    sh:minCount 1 ;
    sh:in ("inbox" "next" "waiting" "someday" "calendar" "reference" "completed")
  ] .

# A Person must have a name and an orgRef
app:PersonShape a sh:NodeShape ;
  sh:targetClass schema:Person ;
  sh:property [ sh:path schema:name ; sh:minCount 1 ] ;
  sh:property [ sh:path app:orgRef ; sh:minCount 1 ] ;
  sh:property [
    sh:path app:orgRole ;
    sh:in ("member" "founder" "accountant" "advisor" "interest")
  ] .
```

### Validation Libraries

JavaScript SHACL validators that run in Node.js and browser:

- [`rdf-validate-shacl`](https://github.com/zazuko/rdf-validate-shacl)
- [`shacl-engine`](https://github.com/rdf-ext/shacl-engine)

Shapes are defined once in `.ttl` files within `packages/core/validation/shacl/` and used by both
the CLI (client-side) and the backend (server-side).

---

## Feature 3: CEL Business Rules

[CEL](https://cel.dev/) (Common Expression Language) handles business rules that go beyond graph
shape constraints — transition rules, field immutability, access control.

### Example Rules

```cel
// Inbox items can only triage to these target buckets
item.bucket == "inbox" && target_bucket in ["next", "waiting", "someday", "calendar", "reference"]

// LOG.md is append-only — content can only grow
new_content.startsWith(old_content)

// Archived items cannot be modified
!(item.bucket == "completed" && operation == "update")

// Only agents can write to AGENT.md
item.orgDocType == "agent" && caller.role in ["agent", "admin"]
```

### CEL Libraries

- [`cel-js`](https://github.com/nicholasgasior/cel-js) — JavaScript CEL implementation
- Rules defined as JSON in `packages/core/validation/cel/rules.json`
- Same rules evaluated client-side (fail fast) and server-side (enforce)

---

## Fail-Fast Validation Pattern

```txt
Client (browser / CLI / Copilot)              Server (backend)
────────────────────────────              ──────────────────
1. Build JSON-LD (serializers)
2. SHACL validate (fail fast)  ────────→  4. SHACL validate (enforce)
3. CEL rules check (fail fast) ────────→  5. CEL rules check (enforce)
                                          6. Persist to PostgreSQL
```

Client catches errors instantly (no roundtrip). Server enforces at the trust boundary (never trusts
client validation alone). Same shapes and rules in both places — single source of truth in the core
package.

---

## Why TypeScript

| Consideration           | TypeScript                                             | Python                              |
| ----------------------- | ------------------------------------------------------ | ----------------------------------- |
| Frontend canonical code | Already exists (`item-serializer.ts`, `api-client.ts`) | Would be a copy                     |
| Browser-compatible      | Yes — 3rd party web clients validate in-browser        | No                                  |
| SHACL libraries         | `rdf-validate-shacl`, `shacl-engine`                   | `pyshacl` (server-only)             |
| CEL libraries           | `cel-js`                                               | `cel-python` (server-only)          |
| Copilot integration     | subprocess or HTTP from Python Haystack                | Native but duplicates frontend code |
| Single codebase         | One implementation, three consumers                    | Two implementations that drift      |

---

## Why CLI over Query Languages

[NeurIPS'24 benchmark](https://medium.com/data-science/can-llms-talk-sql-sparql-cypher-and-mongodb-query-language-mql-equally-well-a478f64cc769)
comparing LLM accuracy across query languages:

| Approach                  | Zero-shot accuracy                     |
| ------------------------- | -------------------------------------- |
| **Tool/function calling** | ~95%+ (models are fine-tuned for this) |
| SQL                       | ~47%                                   |
| Cypher (Neo4j)            | ~34%                                   |
| SPARQL                    | &lt;4%                                 |

Named CLI commands are structured tool calls with discoverability (`--help`) and composability.
LLMs are explicitly trained for tool use — fighting that with query languages is working against the
grain.

If relationship traversal ever outgrows named commands (50+ entities, complex cross-org joins), a
`copilot graph query "..."` subcommand can be added. But JSON-LD already is valid RDF — the data is
ready, the need just isn't there yet.

---

## Implementation Phases

### Phase 1: Baseline + Extract & CLI (enables Copilot)

1. Verify current agent flow is green (`agents/tests/test_copilot.py`, `agents/tests/test_tool_executor.py`, `agents/tests/test_jsonld_builders.py`, `agents/tests/test_backend_client.py`)
2. Add parity tests that lock tool-call schema, JSON output contracts (`copilot.v1`), and exit codes
3. Create `packages/core/` with TypeScript project
4. Move `item-serializer.ts` and `api-client.ts` to core, re-export from frontend
5. Add CLI entry point with subcommands (`items`, `orgs`, `projects`, `auth`, `proposals`)
6. Wire as single `copilot_cli` tool in Haystack using `argv` arrays, replace Python tool executor dispatch with CLI subprocess call
7. Update system prompt to document CLI commands and proposal/apply semantics
8. Remove old tool-call definitions only after parity tests pass

### Phase 2: SHACL Shapes

1. Define SHACL shapes for each `@type` (`Action`, `Person`, `Project`, `CreativeWork`, `DigitalDocument`)
2. Add `validate()` call to CLI write commands (fail fast)
3. Add server-side SHACL validation in backend item creation/update endpoints

### Phase 3: CEL Rules

1. Define business rules as CEL expressions
2. Integrate CEL evaluation into CLI and backend
3. Bucket transition rules, field immutability, access control

### Current Completion Snapshot

- [x] Single `copilot_cli` tool with `argv: string[]` wired through subprocess execution
- [x] Stable machine envelope (`copilot.v1`) for success + error responses
- [x] Renamed CLI identity to Senticor Copilot (`senticor-copilot`, alias `copilot`)
- [x] Token/non-interactive agent mode (`COPILOT_TOKEN`, `COPILOT_HOST`, `COPILOT_ORG_ID`, `--json`, `--non-interactive`, `--yes`)
- [x] Org-scoped canonical IDs (`urn:app:org:<org-id>:<type>:<uuid>`) with default-org fallback
- [x] Collaboration-critical writes: `projects create`, `items create`, `items triage`, `proposals apply`
- [x] Core validation baseline integrated in CLI and backend
- [x] Full weekly planning/scheduling/review dogfooding loop validated with only Senticor Project as tracker

### Phase 4: Future

- Graph query subcommand if/when relationship traversal outgrows named commands
- FRBR/LexCEL ontology work drives this naturally
- JSON-LD remains RDF-compatible — Fuseki or Apache AGE can be added as a projection

---

## Files to Modify/Create

| Layer    | File                                   | Change                                                           |
| -------- | -------------------------------------- | ---------------------------------------------------------------- |
| Core     | NEW: `packages/core/package.json`      | Package setup, TypeScript config                                 |
| Core     | NEW: `packages/core/cli/index.ts`      | CLI entry point                                                  |
| Core     | NEW: `packages/core/cli/items.ts`      | Items subcommands                                                |
| Core     | NEW: `packages/core/cli/orgs.ts`       | Orgs list/get subcommands                                        |
| Core     | NEW: `packages/core/cli/projects.ts`   | Projects subcommands                                             |
| Core     | NEW: `packages/core/cli/auth.ts`       | Auth commands (`login`, `status`)                                |
| Core     | NEW: `packages/core/cli/proposals.ts`  | Proposal/apply workflow commands                                 |
| Core     | NEW: `packages/core/cli/output.ts`     | Stable `copilot.v1` JSON envelope + error mapping                |
| Core     | `packages/core/serializers/`           | Extracted from `item-serializer.ts`                              |
| Core     | `packages/core/client/`                | Extracted from `api-client.ts`                                   |
| Core     | NEW: `packages/core/validation/shacl/` | SHACL shape definitions (`.ttl`)                                 |
| Core     | NEW: `packages/core/validation/cel/`   | CEL rule definitions                                             |
| Frontend | `frontend/src/lib/item-serializer.ts`  | Re-export from `@project/core`                                   |
| Frontend | `frontend/src/lib/api-client.ts`       | Re-export from `@project/core`                                   |
| Agents   | `agents/copilot.py`                    | Replace 3 tools with single `copilot_cli` tool (legacy filename) |
| Agents   | `agents/tool_executor.py`              | Replace per-tool dispatch with TS CLI subprocess execution       |
| Agents   | `agents/jsonld_builders.py`            | Deprecated (replaced by core serializers)                        |
| Agents   | `agents/backend_client.py`             | Deprecated (replaced by core client)                             |
| Agents   | `agents/prompts/de/copilot_system.j2`  | CLI command documentation                                        |
| Monorepo | `package.json`                         | Workspace config for `packages/core`                             |
| Monorepo | `tsconfig.json`                        | Project reference to `packages/core`                             |

---

## Verification

1. Repo gate: `npm run preflight:local`.
2. CLI contract gate: `copilot_cli` calls always use `argv[]`, `--json`, `--non-interactive`, `--yes`, and return `copilot.v1` envelopes.
3. Weekly dogfooding prompt (manual E2E in Copilot chat):
   `Please review everything created/updated/completed this week, suggest what I should prioritize next week, and create whatever is missing (project grouping, mid-week check event, closing stale actions, references). Use only Senticor as tracker.`
4. Expected read behavior: Copilot gathers state via `copilot_cli` (`items list --json`, `items list --bucket completed --json`, optionally `projects actions list --project=<id> --json`).
5. Expected review output: concise sections for (a) created/updated this week, (b) completed this week, (c) blockers/stale work, (d) top priorities for next week.
6. Expected proposal behavior: Copilot emits approval-card write proposals through `copilot_cli` when useful:
   - `projects create ... --apply --json`
   - `items create --type Action --bucket calendar ... --apply --json` (mid-week check)
   - `items triage ... --bucket completed|waiting|next --apply --json`
   - `items create --type CreativeWork ... --apply --json` (weekly review reference)
7. Acceptance criterion: human + Copilot can complete weekly planning/scheduling/review inside Senticor Project with no external tracker dependency.
