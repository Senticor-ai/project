import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Product/Epics/PWA Readiness" />

# Epic: PWA Readiness

**Status:** Not started
**Priority:** Future

## Context

A gap analysis against the Procedere team's PWA-readiness checklist confirmed that terminandoyo's core SPA architecture is solid: React Query hooks provide a swappable repository abstraction, optimistic mutations with rollback are universal, the OfflineBanner + `offlineFirst` network mode handle connectivity state, and the backend offers cursor-based sync with ETags and idempotent writes.

The remaining gaps before terminandoyo can become an installable, offline-capable PWA fall into four phases:

1. Touch & mobile audit (prerequisite for any mobile deployment)
2. Write conflict prevention (optimistic concurrency on the backend)
3. Reverse proxy rate limiting (security hardening for production)
4. PWA infrastructure (manifest, service worker, IndexedDB, background sync)

**Design goal:** Users can install terminandoyo on mobile, work offline, and have changes sync automatically when reconnected — without any UI component rewrites.

---

## Phase 1: Touch & Mobile Audit

### 1a. RED — Touch target audit

Verify all interactive elements meet the 44x44 CSS pixel minimum (Apple HIG / WCAG 2.5.8).

**Components to audit:**

| Component | Concern |
| --- | --- |
| `BucketNav` buttons | Compact sidebar — may be too small on phone |
| `ActionRow` checkbox + focus toggle | Inline controls could be undersized |
| `ObjectCard` action buttons | Archive/move buttons in card footer |
| `EditableTitle` | Double-click to edit has no touch equivalent |
| `InboxTriage` bucket buttons | Quick-triage actions need adequate spacing |
| `AppMenu` dropdown items | Menu items need touch-safe hit targets |
| `Tabs` component | Tab headers need adequate tap area |

**Test approach:**
- Chrome DevTools device mode with touch simulation
- Storybook mobile viewport stories for each component
- Automated check: Playwright `boundingBox()` assertions for min 44x44

### 1b. GREEN — Fix undersized targets and hover-only interactions

**`EditableTitle` (double-click → long-press or edit button):**

`frontend/src/components/work/EditableTitle.tsx`:
- Add an explicit edit icon button (visible on touch devices, hidden on hover for desktop)
- Use `@media (pointer: coarse)` to always show the edit affordance on touch devices
- Keep double-click as a desktop shortcut

**General fixes:**
- Add `min-h-11 min-w-11` (44px) to all small interactive elements
- Ensure adequate spacing between adjacent tap targets (8px minimum)

### 1c. RED — Mobile keyboard tolerance

`frontend/src/components/work/InboxCapture.tsx`, `frontend/src/components/work/ItemEditor.tsx`:
- Verify input fields remain visible when the virtual keyboard opens
- Test with `visualViewport` API in Storybook or Playwright mobile emulation
- Ensure no content is permanently obscured by the keyboard

### 1d. VERIFY

```bash
cd frontend && CI=1 npx vitest run --project=unit
cd frontend && npx tsc -b --noEmit
# Manual: Chrome DevTools → Toggle Device Toolbar → test each component
```

---

## Phase 2: Write Conflict Prevention

### 2a. RED — Tests for If-Match precondition

`backend/tests/test_conflict_detection.py`:
- `PATCH /items/{id}` with correct `If-Match` ETag succeeds (200)
- `PATCH /items/{id}` with stale `If-Match` ETag returns 412 Precondition Failed
- `PATCH /items/{id}` without `If-Match` header succeeds (backward compatible)
- Response includes `ETag` header matching the item's content hash

### 2b. GREEN — Implement If-Match on PATCH

`backend/app/routes/items.py` — existing `update_item` handler:

The ETag infrastructure already exists:
- `_hash_payload()` computes SHA256 of merged JSON-LD (line 34-36)
- `content_hash` stored in items table (line 69)
- ETags computed from content_hash + metadata (lines 39-41)
- `If-None-Match` already supported on GET/sync for cache validation

Add `If-Match` support:
```python
if_match = request.headers.get("If-Match")
if if_match:
    current_etag = _compute_etag(existing_item)
    if if_match.strip('"') != current_etag.strip('"'):
        raise HTTPException(
            status_code=status.HTTP_412_PRECONDITION_FAILED,
            detail="Resource has been modified since last read",
        )
```

### 2c. GREEN — Frontend sends If-Match on updates

`frontend/src/lib/api-client.ts` — `ItemsApi.update()`:
- Accept optional `etag` parameter
- Set `If-Match` header when provided
- Handle 412 response: invalidate cache, show toast "Item was modified elsewhere"

`frontend/src/hooks/use-mutations.ts`:
- Pass item's ETag from cache to update calls
- On 412 error, invalidate query and show conflict toast

### 2d. VERIFY

```bash
cd backend && uv run python -m pytest tests/test_conflict_detection.py -v
cd backend && uv run ruff check app/routes/items.py
cd backend && uv run mypy app/routes/items.py
cd frontend && CI=1 npx vitest run --project=unit
cd frontend && npx tsc -b --noEmit
```

---

## Phase 3: Reverse Proxy Rate Limiting

### 3a. RED — Integration test for rate limiting

`backend/tests/test_rate_limiting.py` (integration, requires nginx):
- 100+ write requests within 1 minute → 429 Too Many Requests
- Response includes `Retry-After` header
- Auth endpoints limited to 10 failed attempts per minute

### 3b. GREEN — nginx rate limiting configuration

`deploy/nginx/rate-limit.conf`:

```nginx
# Rate limit zones
limit_req_zone $binary_remote_addr zone=writes:10m rate=100r/m;
limit_req_zone $binary_remote_addr zone=auth:10m rate=10r/m;

# Apply to write endpoints
location ~ ^/(items|imports|files) {
    limit_req zone=writes burst=20 nodelay;
    limit_req_status 429;
    proxy_pass http://backend;
}

# Apply to auth endpoints
location /auth/login {
    limit_req zone=auth burst=5 nodelay;
    limit_req_status 429;
    proxy_pass http://backend;
}

location /auth/register {
    limit_req zone=auth burst=5 nodelay;
    limit_req_status 429;
    proxy_pass http://backend;
}
```

### 3c. Observability

**nginx access logs** with rate limit status:

```nginx
log_format rate_limited '$remote_addr - $request '
                        '$status $limit_req_status';
```

**Alloy → Loki pipeline**: Parse `$limit_req_status` field from nginx logs for dashboarding.

**Prometheus**: Track `nginx_http_requests_total{status="429"}` via nginx-exporter or Alloy metric extraction for alerting on rate limit spikes.

### 3d. VERIFY

```bash
# Load test with hey or wrk
hey -n 200 -c 10 -m POST http://localhost/items ...
# Expect 429 responses after ~100 requests
```

---

## Phase 4: PWA Infrastructure

### 4a. RED — PWA installability checks

- Lighthouse PWA audit passes (manifest, service worker, HTTPS, icons)
- App installs on Chrome Android and Safari iOS
- Offline shell loads when network is down

### 4b. GREEN — Web app manifest

`frontend/public/manifest.json`:

```json
{
  "name": "TerminAndoYo",
  "short_name": "TAY",
  "description": "GTD-inspired task management",
  "start_url": "/workspace/inbox",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#18181b",
  "icons": [
    { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png" },
    { "src": "/icons/icon-maskable-512.png", "sizes": "512x512", "type": "image/png", "purpose": "maskable" }
  ]
}
```

`frontend/index.html` — add manifest link:
```html
<link rel="manifest" href="/manifest.json" />
<meta name="theme-color" content="#18181b" />
```

### 4c. GREEN — Service worker via vite-plugin-pwa

`frontend/package.json` — add dependency:
```bash
npm install -D vite-plugin-pwa
```

`frontend/vite.config.ts` — configure Workbox:
```typescript
import { VitePWA } from "vite-plugin-pwa";

plugins: [
  // ... existing plugins
  VitePWA({
    registerType: "autoUpdate",
    workbox: {
      globPatterns: ["**/*.{js,css,html,ico,png,svg,woff2}"],
      runtimeCaching: [
        {
          urlPattern: /^https:\/\/.*\/items\/sync/,
          handler: "NetworkFirst",
          options: { cacheName: "api-sync", expiration: { maxEntries: 50 } },
        },
      ],
    },
  }),
]
```

**Caching strategy:**
- Static assets (JS, CSS, fonts, icons): **CacheFirst** — immutable content-hashed files
- API sync endpoint: **NetworkFirst** — try network, fall back to cache
- HTML shell: **StaleWhileRevalidate** — serve cached, update in background

### 4d. GREEN — IndexedDB persistence (future)

When offline persistence becomes a priority:

- Use `idb-keyval` or `Dexie.js` as IndexedDB wrapper
- Create a React Query `persistQueryClient` adapter
- Store query cache in IndexedDB keyed by query hash
- On app launch: hydrate from IndexedDB, then sync from server
- Files: new `frontend/src/lib/offline-storage.ts`

### 4e. GREEN — Background Sync (future)

When the service worker is in place:

- Register mutations as Background Sync tasks
- Service worker replays queued mutations when connectivity returns
- React Query's `offlineFirst` mode already queues mutations client-side
- Background Sync ensures they execute even if the tab is closed
- Files: service worker script, `frontend/src/lib/sync-manager.ts`

### 4f. VERIFY

```bash
cd frontend && npx tsc -b --noEmit
cd frontend && npm run build
# Lighthouse audit on built app
npx lighthouse http://localhost:4173 --only-categories=pwa --output=json
# Manual: Chrome → Install app → disable network → verify offline shell
```

---

## Files to create/modify

**Phase 1 (Touch audit):**
- `frontend/src/components/work/EditableTitle.tsx` — add touch edit affordance
- Various components — add `min-h-11 min-w-11` to small targets

**Phase 2 (Conflict prevention):**
- `backend/tests/test_conflict_detection.py` — new test file
- `backend/app/routes/items.py` — add `If-Match` precondition check
- `frontend/src/lib/api-client.ts` — pass ETag on updates
- `frontend/src/hooks/use-mutations.ts` — handle 412 responses

**Phase 3 (Rate limiting):**
- `deploy/nginx/rate-limit.conf` — new nginx config
- `deploy/alloy/config.alloy` — log parsing pipeline

**Phase 4 (PWA):**
- `frontend/public/manifest.json` — new web app manifest
- `frontend/public/icons/` — PWA icons (192, 512, maskable)
- `frontend/index.html` — manifest link + theme-color meta
- `frontend/vite.config.ts` — add vite-plugin-pwa
- `frontend/src/lib/offline-storage.ts` — IndexedDB adapter (future)

---

## Verification checklist

- [ ] All interactive elements meet 44x44px minimum on touch devices
- [ ] EditableTitle has touch-friendly edit affordance
- [ ] Mobile keyboard does not obscure input fields
- [ ] `If-Match` on PATCH returns 412 when stale
- [ ] Frontend handles 412 with cache invalidation + toast
- [ ] nginx rate limiting returns 429 after threshold
- [ ] Rate limit events visible in Loki dashboards
- [ ] `manifest.json` present with correct metadata and icons
- [ ] Service worker caches static assets and API responses
- [ ] Lighthouse PWA audit passes
- [ ] App installs on mobile browsers
- [ ] Offline shell loads when disconnected
- [ ] All backend tests pass (`pytest`)
- [ ] All frontend tests pass (`vitest run`)
- [ ] TypeScript clean (`tsc -b --noEmit`)
