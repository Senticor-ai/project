import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Product/Epics/Inbox to Calendar Event Workflow" />

# Epic: Inbox to Calendar Event Workflow

**Status:** Delivery in progress (spec + implementation slices active)
**Priority:** Current
**Checklist audit:** February 25, 2026 -- rewritten to development-ready contract; all acceptance criteria remain unchecked until implementation lands.
**Last updated:** 2026-02-25
**Depends on:** Google Workspace connector baseline, Items/Event serializer parity, Calendar bucket UX, project association model, sync worker reliability
**Related:** [Completed Epic: Gmail + Google Calendar MVP Integration](?path=/docs/product-completed-epics-gmail-google-calendar-mvp-integration--docs)

## Context

The product currently has partial calendar capabilities across triage, sync, and UI, but they are not yet a cohesive end-to-end user workflow.

### Current reality (as of February 25, 2026)

- Google Calendar sync can import events as `@type: "Event"` with `app:bucket = "calendar"`.
- Initial sync uses a bounded window (`now - 7 days` to `now + 30 days`), not "all current day and future events."
- Work surface item queries are action-centric and do not consistently surface synced `Event` items in the same way as action items.
- Inbox triage `Move to Calendar` requires selecting a date first, but persistence still defaults to `@type: "Action"` for triage moves.
- Google Calendar write calls exist in proposal-confirm flows, but there is no direct "accept / reject / tentative / reschedule / delete" event control surface in the main Project calendar UI.
- Calendar grid in the main work surface is still spec-only.

### Problem statement

Users expect calendar sync to behave as a single, reliable system:

1. Enabling calendar sync should make current-day and future events visible in Project calendar views.
2. Events visible in Project should be actionable (accept/decline/tentative, reschedule, delete).
3. Changes made in Project should propagate back to Google Calendar (when the source event is Google-managed and permissions allow).
4. Inbox-to-calendar triage should create true events, not pseudo-calendar actions.
5. Time-sensitive email + calendar context should proactively surface Copilot proposals with browser notifications and confirmation-required execution.

## User Story

> "When I move something from inbox to calendar, I want it to become a real event with a date. When calendar sync is enabled, I want to see synced events in Project and manage them there (accept/decline/tentative, reschedule, delete) with reliable Google propagation."

## Goals

1. Make inbox-to-calendar deterministic: triage to calendar creates `Event` by default.
2. Enforce date assignment on calendar placement.
3. Make synced events first-class in Project calendar surfaces.
4. Provide both List and Calendar (grid) views with parity for core event actions.
5. Support project filtering and project association/disassociation from both views.
6. Support in-product event actions that propagate to Google when applicable.
7. Define robust error/retry/permission behavior so users can trust sync.
8. Ensure urgent Copilot proposal flows are visible and executable end-to-end from browser alert to Google+email writeback.

## Delivery Plan (6 Items)

1. **Calendar visibility + write APIs**
   - `GET/PATCH/POST RSVP/DELETE /calendar/events`
   - start-of-today to +365 day initial sync horizon
   - Status: Implemented
2. **Calendar bucket UX parity**
   - List/Week/Month, shared details panel, RSVP/reschedule/delete actions
   - Status: Implemented (`Work/CalendarView`)
3. **Urgent proposal trigger + notification orchestration**
   - proposals auto-generated from email/calendar context
   - urgent proposals emit browser/in-app notifications and deep-link to Copilot
   - Status: Implemented
4. **Busy-agent durability guarantees**
   - `proposal_candidates` queue with lease/retry/dead-letter semantics
   - Status: Implemented
5. **CLI operator/runtime support**
   - `notifications send`, `notifications watch --sse`, `proposals watch`
   - Status: Implemented
6. **Deterministic mock harness + Storybook flow docs**
   - mock Gmail/Calendar harness + urgent scenario seed script
   - human tester playbook documented in Storybook flow docs
   - Status: Implemented ([Flow: Inbox to Calendar + Copilot Alerts](?path=/docs/flows-inbox-to-calendar-copilot-alerts--docs))

## Scope

### In scope

- Inbox triage -> calendar converts to `@type: "Event"` by default.
- Date guardrail for calendar placement.
- Calendar views:
  - List mode
  - Calendar grid mode (MVP: Month + Week)
- Calendar data visibility:
  - local events
  - Google-synced events from selected calendars
- Project filter and project association/disassociation in both modes.
- Event action controls in Project UI:
  - Accept
  - Tentative
  - Decline
  - Reschedule
  - Delete
- Copilot proposal automation for urgent workflows:
  - meeting reschedule requests close to event time
  - personal pickup/errand requests
- Browser alert for urgent proposals, with in-app fallback when notification permission is unavailable.
- Confirmation-required execution for all Copilot write actions.
- Google propagation behavior for those actions (subject to permissions/source).
- Migration/compat logic for existing calendar `Action` items.
- Telemetry, audit, and test coverage for critical flows.

### Out of scope (for this epic)

- Outlook/Microsoft calendar support.
- "Propose new time" negotiation UX and email threading automation.
- Full recurrence-series editor redesign (only "this occurrence" behavior in MVP).
- Multi-user scheduling conflict solver.
- Offline-first sync queue for mobile local DB (basic retry only in MVP).

## Product decisions locked for this epic

1. Event date canonical field:
   - Date/time is stored on `Event.startDate` (required).
   - `Event.endDate` is optional but required when a timed duration is known.
2. Date-only vs datetime:
   - All-day events use date string (`YYYY-MM-DD`).
   - Timed events use timezone-qualified ISO datetime.
3. Inbox -> calendar default:
   - Creates/patches to `@type: "Event"` (not `Action`).
4. Multi-project support:
   - Events support multi-project links via `app:projectRefs[]`.
   - Filter semantics in MVP: `Any selected`.
5. Calendar modes in MVP:
   - Month + Week grid.
   - Day view deferred.
6. Edit parity:
   - List and grid both open the same event detail/editor surface with identical core actions.
7. Disassociation behavior:
   - Removing project links does not move event out of calendar; it only updates association metadata.
8. Existing calendar `Action` records:
   - One-time migration + compatibility fallback during rollout.
9. Copilot write safety:
   - all Copilot-generated write actions are proposal-first and require explicit user confirmation.

## End-to-end functional specification

### FR-0: Copilot proposal trigger and urgency contract

The system must generate proposal candidates from new email and calendar context without requiring manual "generate proposals" action in normal use.

Trigger sources:

1. new synced Gmail message
2. relevant calendar event updates (time/attendee changes)

Proposal classes in scope:

- `Proposal.RescheduleMeeting`
- `Proposal.PersonalRequest`

Urgency criteria (MVP defaults, configurable):

- event-linked proposal where target event starts within next `4 hours`, or
- classifier marks request as urgent/time-critical.

Notification behavior:

- For urgent proposals, show browser notification (if permission granted).
- If browser notification permission is denied/not granted, show in-app high-priority alert.
- Notification click opens the proposal review surface with suggested actions preloaded.

Safety and dedupe:

- Same source email + proposal type must not produce duplicate pending proposals.
- Each proposal remains confirmation-required before any Google Calendar or Gmail write is executed.

Reference scenario (must pass E2E):

1. User has a 4:00 PM meeting on calendar.
2. At 3:00 PM, an email arrives from the same participant asking to move by 30 minutes.
3. Copilot correlates email + event and creates `Proposal.RescheduleMeeting`.
4. User receives browser alert.
5. User opens proposal and confirms.
6. System updates calendar event (+30 min), sends reply email confirming the move, and persists audit log.
7. Updated event state is reflected in Project and propagated to Google Calendar.

### FR-1: Enable calendar sync -> visibility contract

When a user enables calendar sync for one or more Google calendars:

1. System performs initial backfill from local start-of-day today through `+365 days`.
2. System then switches to incremental updates via per-calendar sync token.
3. Project calendar views must show synced events once first sync succeeds.
4. Visibility includes all events whose start date is today or in the future within loaded horizon.
5. When user navigates beyond loaded horizon in grid mode, system loads next range segment and extends local cache.

Notes:

- This satisfies "current day and future events visible" while keeping initial sync bounded.
- Past events can remain available in data store but are not default-visible in this epic's calendar view.

### FR-2: Inbox triage to calendar must create true events

Flow:

1. User clicks **Move to Calendar** from inbox item.
2. Date input is mandatory before confirm.
3. Optional time input supported (all-day if omitted).
4. On confirm:
   - item persisted as `@type: "Event"`
   - `app:bucket = "calendar"`
   - `startDate` populated
   - `endDate` inferred from duration or left null for all-day/no-duration
5. If user cancels date entry:
   - explicit options shown:
     - Keep in Inbox
     - Move to Next
   - default is Keep in Inbox

### FR-3: Calendar views with parity

Calendar bucket provides two modes:

- **List mode:** chronological list grouped by day.
- **Grid mode:** Month + Week.

Both modes must support:

- open event details
- edit title/description/time
- project associate/disassociate
- RSVP actions (accept/tentative/decline) when applicable
- reschedule
- delete
- visual sync state (in sync, pending, failed)

### FR-4: Event action semantics and Google propagation

Action matrix:

| User action in Project | Local update                              | Google API behavior                                                     | Availability                                                               |
| ---------------------- | ----------------------------------------- | ----------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| Accept                 | `app:rsvpStatus = accepted`               | `events.patch` attendee response status for current user                | Google event where user is attendee                                        |
| Tentative              | `app:rsvpStatus = tentative`              | `events.patch` attendee response status                                 | Google attendee events                                                     |
| Decline                | `app:rsvpStatus = declined`               | `events.patch` attendee response status                                 | Google attendee events                                                     |
| Reschedule             | Update `startDate`/`endDate`              | `events.patch` start/end                                                | Events on writable calendars (`owner`/`writer`)                            |
| Delete                 | Soft-archive local item + tombstone/audit | `events.delete` for writable events; decline fallback when not writable | Writable events for hard delete; attendee-only events get decline fallback |

Propagation rules:

- For Google-sourced events (`sourceMetadata.provider = google_calendar`), user actions trigger Google write attempts.
- For local-only events (no provider binding), actions apply locally only.
- Provider write calls are idempotent and auditable.
- UI shows pending state until provider response is confirmed.

### FR-5: Project association in calendar

- Event supports `app:projectRefs[]` (0..n).
- Add/remove project links from list and grid.
- Calendar filter supports selecting multiple projects with `Any selected` matching.
- Event with zero project refs still remains in calendar and appears when no project filter is active.

### FR-6: Sorting and rendering rules

For a given day in list mode:

1. all-day events first
2. timed events sorted by start datetime ascending
3. untimed legacy events (if any) at end with "time not set" label

Grid mode:

- all-day lane at top
- timed events in day/time slots
- recurring badge if event is recurring instance

### FR-7: Permissions and editability rules

- Calendar access role from selected Google calendar controls writable actions:
  - `owner` / `writer`: reschedule and delete enabled
  - `reader` / `freeBusyReader`: read-only for time/delete
- RSVP actions available only when user appears in attendees.
- When action unavailable, show disabled control with reason tooltip.

### FR-8: Recurrence behavior (MVP)

- For recurring events, edits/deletes in this epic apply to single occurrence only.
- "Edit entire series" and advanced recurrence editor are out of scope.
- UI must clearly label "This occurrence only."

## Data model and storage contract

### Canonical JSON-LD event requirements

Required:

- `@type = "Event"`
- `@id` canonical id
- `name`
- `startDate`
- `additionalProperty` includes `app:bucket = "calendar"`

Recommended additional properties for this epic:

- `app:projectRefs: string[]`
- `app:rsvpStatus: "needsAction" | "accepted" | "tentative" | "declined"`
- `app:calendarSyncState: "in_sync" | "pending_write" | "write_failed" | "local_only"`
- `app:calendarWritable: boolean`
- `app:calendarRole: "owner" | "writer" | "reader" | "freeBusyReader" | "unknown"`

Provider identity (for Google propagation):

- retain `sourceMetadata.provider = "google_calendar"`
- retain `sourceMetadata.raw.calendarId`
- retain `sourceMetadata.raw.eventId`

### ID strategy

- Google-sourced events keep provider-derived canonical IDs (`urn:app:event:gcal:{calendarId}:{eventId}`).
- Locally created events without immediate provider create use local IDs (`urn:app:event:local:{uuid}`) and `app:calendarSyncState = local_only`.
- If local event is later pushed to Google, store provider link metadata and keep canonical ID stable.

## API and backend behavior contract

### New/extended API surface (MVP)

1. `GET /calendar/events`
   - query: `from`, `to`, `project_ids[]`, `include_local_only`
   - returns normalized event records for list/grid rendering.
2. `POST /calendar/events`
   - creates event from Project UI and optionally writes to Google when sync enabled.
3. `PATCH /calendar/events/{canonical_id}`
   - updates local event fields and writes through when provider-bound + allowed.
4. `POST /calendar/events/{canonical_id}/rsvp`
   - body: `{ status: accepted|tentative|declined }`
   - updates local + provider attendee response.
5. `DELETE /calendar/events/{canonical_id}`
   - delete semantics per permissions matrix.

Implementation note:

- Backend may internally reuse existing `items` and `google_calendar_api` modules; this contract is about behavior and payload semantics.

### Proposal automation + notification integration

- Existing proposal endpoints (`/email/proposals`, `/email/proposals/generate`, confirm/dismiss) remain source of truth for proposal entities.
- Proposal generation is invoked automatically from sync/update workflows for new candidate events/messages.
- Frontend monitors pending proposals and issues browser notification for newly created urgent proposals.
- Notification payload includes:
  - proposal type label
  - counterpart (sender/attendee)
  - target event time
  - recommended action summary
- Clicking notification deep-links to proposal review UI.

## Technical specification

### TS-0: Central CEL rule catalog (enforced)

Google Workspace sync/proposal decision rules are centralized in:

- `backend/app/email/rules/sync_behavior_rules.json`

Runtime enforcement uses `backend/app/email/cel_rules.py` and is applied in:

- `backend/app/email/sync.py`
- `backend/app/email/proposals.py`

This keeps decision logic reviewable and change-controlled in one place while still executing in production code paths.

### TS-1: Wake-up and event propagation model

Use existing outbox/event infrastructure as the canonical wake-up path:

1. Persist domain event in `outbox_events`.
2. Emit Postgres `pg_notify` on configured outbox channel.
3. Worker process wakes via `LISTEN/NOTIFY` and processes event with near-zero idle latency.

Event types added for this epic:

- `proposal_candidate_detected`
- `proposal_created`
- `proposal_urgent_created`
- `proposal_confirmed`
- `proposal_dismissed`

This keeps proposal automation aligned with existing worker architecture and avoids introducing a parallel trigger bus.

### TS-2: How the agent learns about new urgent context

Decision:

- Agent container does not connect directly to Postgres for wake-ups.
- Backend owns DB connections and emits an SSE stream for agent/runtime consumers.

New SSE stream (backend):

- `GET /notifications/stream`
- event types: `proposal_created`, `proposal_urgent_created`, `proposal_updated`
- payload includes `event_id`, `proposal_id`, `proposal_type`, `urgency`, `created_at`, `target_user_id`, deep-link URL

Agent wake behavior:

- Agent runtime subscribes to SSE stream.
- On urgent proposal events, agent can fetch proposal details and prepare follow-up suggestions.
- Execution remains confirmation-gated; no autonomous write action.

### TS-3: CLI support for wake + notification workflows

CLI additions (copilot CLI):

1. `notifications watch --sse`
   - subscribes to `/notifications/stream`
   - machine-readable output for automation (`--json`)
2. `notifications send --title ... --body ... [--url ...] [--target-user-id ...]`
   - enqueues notification through backend notification API
   - usable by human operator, agent tool flow, and automation scripts
3. `proposals watch [--urgent-only]`
   - convenience wrapper for urgent proposal stream consumption

Requirement:

- Agent-triggered and CLI-triggered notifications must use the same backend envelope and delivery pipeline as system-generated urgent proposal alerts.

### TS-4: Unified notification envelope

Introduce shared notification payload contract used by push, SSE, and in-app UI:

```json
{
  "event_id": "uuid",
  "kind": "proposal_urgent",
  "severity": "info|warning|critical",
  "title": "Urgent: meeting update suggested",
  "body": "Alex requested moving your 4:00 PM meeting by 30 minutes.",
  "url": "/settings/email?proposal=...",
  "proposal_id": "uuid",
  "target_user_id": "uuid",
  "created_at": "ISO-8601"
}
```

All producers (worker, agent, CLI, API route) must emit this schema.

### TS-5: Browser + in-window notification integration

Frontend `NotificationOrchestrator` (new app-level module) behavior:

1. Consume SSE notifications while app is open.
2. Always create an in-window notification entry (in-app source of truth).
3. Trigger toast via existing `ToastProvider` for urgent events.
4. Trigger browser `Notification` when permission is granted.
5. Deduplicate by `event_id` so one event does not show duplicate toast/browser alerts.

Focus rules:

- If tab is visible/focused: show in-window notification + toast; browser notification optional (configurable, default off).
- If tab is hidden/background: show browser notification plus in-window notification entry.
- If permission denied: skip browser notification, keep in-window notification + toast.

### TS-6: Notification storage and read model

Add `notification_events` table for in-app feed and SSE replay cursoring:

- `event_id` (PK)
- `org_id`
- `target_user_id`
- `kind`
- `severity`
- `payload` (JSONB)
- `created_at`
- `read_at`

`push_outbox` remains delivery queue for web push transport.
`notification_events` is the user-facing read model and SSE source.

### TS-7: Security and tenancy

- SSE stream and notification queries are user/org scoped.
- CLI watch/send commands require authenticated user session.
- Agent runtime receives delegated token scoped to current user+org.
- Notification payload must never include OAuth tokens or raw provider secrets.

### TS-8: Busy-agent delivery guarantees (no missed events)

Guarantee objective:

- New email/calendar events are never dropped when agent runtime is busy with another task.

Mechanism:

1. On trigger, persist a durable candidate row before agent processing:
   - table: `proposal_candidates` (new)
   - status lifecycle: `queued -> processing -> completed | failed | dead_lettered`
2. Scheduler claims work via lease (not by direct wake-only push):
   - claim query uses `FOR UPDATE SKIP LOCKED`
   - claimed rows set `lease_expires_at`
3. If agent is busy, rows remain `queued` until capacity is available.
4. If agent crashes or hangs, expired lease rows are automatically re-queued.
5. Deduplication key prevents duplicate candidate work:
   - `(source_message_id, proposal_type, target_event_id)`
6. Urgent user notification is emitted when candidate/proposal is persisted, not when agent finishes.
7. Periodic reconciliation pass re-scans recent Gmail history + calendar changes and re-enqueues missing candidates.
8. After max attempts, move to dead letter with operator-visible diagnostics.

Operational controls:

- Queue depth metric, lease-timeout metric, retry-count metric, dead-letter metric.
- Alert on sustained queue age and dead-letter growth.

### TS-9: Timezone storage and rendering contract

- Persist timed event timestamps in backend as UTC (`YYYY-MM-DDTHH:MM:SSZ`) for deterministic cross-device behavior.
- Preserve provider-native temporal payload in `sourceMetadata.raw.start/end` for traceability.
- Keep all-day events as date-only strings (`YYYY-MM-DD`) without timezone conversion.
- Render and group events in frontend using the viewer timezone from browser/OS settings.
- Device timezone changes must only affect presentation (day bucket + wall-clock label), never stored absolute time.

### Writeback execution model

- Synchronous attempt on user action for immediate feedback.
- On transient provider failures: mark `write_failed`, keep retry metadata, offer user-triggered retry.
- On permanent permission failures: keep local state unchanged from last confirmed provider state and show actionable error.
- All write attempts logged to audit with action type, canonical id, provider ids, status, and error detail.

### Concurrency and idempotency

- Mutating endpoints require ETag/version precondition where applicable.
- Conflicts return `409` with latest server version.
- Client must rebase and retry after conflict resolution.
- Idempotency key required for reschedule/delete/rsvp write endpoints.

## UX specification

### Event row/card controls

Mandatory controls in event detail panel:

- Accept
- Tentative
- Decline
- Reschedule (date/time editor)
- Delete
- Project links editor

### Urgent proposal alerts

- Browser notification title format:
  - `Urgent: meeting update suggested`
  - `Urgent: personal request action suggested`
- Browser notification body includes short reason + timing context.
- Alert click opens proposal card with:
  - why this was triggered
  - suggested calendar change
  - draft email reply
  - confirm / dismiss controls

### State indicators

Each event shows one sync badge:

- `Synced`
- `Saving...`
- `Sync failed`
- `Local only`

### Empty and degraded states

- Sync enabled but no events in range:
  - "No upcoming events."
  - CTA: "Refresh sync"
- Calendar API permission issue:
  - inline error with reconnect/settings CTA.
- Write failure:
  - inline toast + event-level retry affordance.

## Migration and compatibility

### Existing calendar Action items

Migration behavior:

1. Identify `Action` items with `app:bucket = "calendar"` and date-like scheduling metadata.
2. Convert to `Event` preserving canonical id and user-entered metadata.
3. Populate `startDate` from best available source:
   - `startTime`
   - fallback `app:scheduledDate`
4. Keep compatibility read path during rollout for non-migrated records.

### Existing Google-synced Event items

- Preserve current canonical IDs and source metadata.
- Backfill new additionalProperty fields lazily on read/update if absent.

## Observability and metrics

Track:

- `% calendar events visible in UI vs synced in backend` (consistency ratio)
- proposal auto-generation rate (per new email/event)
- urgent proposal notification delivery rate
- urgent proposal open-through rate
- urgent proposal confirm-through rate
- RSVP write success rate
- Reschedule write success rate
- Delete write success rate
- median write latency (UI action -> provider confirmed)
- sync failure rate by reason (permissions, quota, conflict, transient)

Alert thresholds:

- write failure rate > 5% for 15m
- calendar sync stale age > 2h for active connections

## Acceptance criteria

- [ ] Enabling calendar sync makes current-day and future synced events visible in Project calendar views.
- [ ] Inbox `Move to Calendar` persists `@type: "Event"` with required date semantics.
- [ ] Calendar supports List and Grid (Month + Week) with parity for core event actions.
- [ ] Project filter works in both modes with `Any selected` semantics for multi-project events.
- [ ] User can accept/tentative/decline eligible events in Project and changes propagate to Google.
- [ ] User can reschedule writable events in Project and changes propagate to Google.
- [ ] User can delete writable events in Project and deletion propagates to Google.
- [ ] Non-writable events show correct disabled states and explanatory feedback.
- [ ] Local and provider sync states are visible (`Synced`, `Saving`, `Sync failed`, `Local only`).
- [ ] Copilot proposal generation is automatically triggered by new email/event sync signals (no manual generate step required for normal flow).
- [ ] Urgent proposals generate browser notifications (or in-app high-priority fallback when notification permission is unavailable).
- [ ] Urgent proposal pipeline uses unified notification envelope and deduplicates by `event_id`.
- [ ] Agent runtime can be woken via backend SSE notification stream without direct Postgres access.
- [ ] CLI supports stream watching and notification send commands via the same backend notification pipeline.
- [ ] Busy agent does not cause missed proposal candidates; queued work is processed after capacity returns.
- [ ] Lease timeout recovers stuck agent tasks and re-queues candidate processing automatically.
- [ ] Dead-lettered candidate tasks are visible with error diagnostics and retry metadata.
- [ ] Confirming urgent reschedule proposal updates Google Calendar and sends confirmation email reply.
- [ ] Confirming urgent personal-request proposal performs mapped calendar/email actions with audit log.
- [ ] Existing calendar `Action` items are migrated (or compatibly rendered) without data loss.
- [ ] Audit logs capture all provider write attempts and outcomes.

## Test plan

### Unit tests

- serializer: action->event conversion paths
- event sorting/render grouping logic
- rsvp state mapping and disabled-action predicates
- migration transform functions

### Integration tests (backend)

- initial backfill horizon behavior (today to +365 days)
- incremental sync token lifecycle
- proposal auto-generation trigger on new email/event updates
- outbox wakeup behavior for proposal events (`LISTEN/NOTIFY`)
- SSE notification stream filtering, auth, and replay cursor behavior
- busy-agent queue lifecycle (`queued/processing/completed/failed/dead_lettered`)
- lease expiry and automatic requeue behavior
- dedupe key correctness for repeated provider events
- reconciliation job catches missed triggers and re-enqueues candidates
- rsvp/reschedule/delete provider call mapping + error handling
- permission matrix (owner/writer/reader/freeBusyReader)
- idempotency and conflict behavior
- timezone normalization: provider offsets -> UTC persistence for timed events; date-only events unchanged
- calendar patch normalization: offset datetime input -> UTC writeback payload + UTC item storage

### Frontend integration tests

- list/grid mode parity for action controls
- sync badge states
- urgent proposal browser notification and in-app fallback behavior
- dedupe behavior across SSE + browser notification + toast (single user-visible alert per `event_id`)
- project filter behavior with multi-project events
- write failure and retry UX
- day grouping uses viewer timezone (not UTC slicing) for list/week/month parity
- event time labels always render in 24-hour `HH:MM` format (no AM/PM)

### End-to-end tests

- enable sync -> events visible
- inbox -> calendar -> event created
- accept/decline/tentative propagate
- reschedule propagate and re-render
- delete propagate and item removed/archived
- urgent reschedule scenario: 3:00 PM inbound email for 4:00 PM meeting -> browser alert -> user confirm -> calendar + email writeback
- urgent personal request scenario: browser alert -> user confirm -> expected write actions executed and audited

## Delivery phases

### Phase 1: Data + API contract lock

- event schema fields and migration plan
- endpoint contracts and error semantics
- permission and action matrix implementation
- proposal trigger + urgency criteria lock

### Phase 2: Backend write path + sync visibility

- event query endpoint for calendar views
- RSVP/reschedule/delete writeback pipeline
- proposal auto-generation hookup in sync flows
- audit + metrics + retries

### Phase 3: Frontend calendar surfaces

- list/grid mode with shared event detail panel
- project filter + association editor
- sync state badges and degraded-state UX
- urgent proposal browser/in-app alert + deep-link review flow

### Phase 4: Rollout and hardening

- staged rollout flag
- migration execution and verification
- SLO monitoring and bugfix sweep

## Risks and mitigations

- Google permission mismatch at runtime
  - Mitigation: explicit role-based UI gating + reconnect CTA.
- Write conflicts with concurrent edits from external clients
  - Mitigation: ETag/version checks + conflict resolution UX.
- Data divergence between local and provider states
  - Mitigation: event-level sync state + retry + reconciliation job.
- Migration regressions from legacy Action calendar data
  - Mitigation: dry-run migration report + compatibility fallback.
