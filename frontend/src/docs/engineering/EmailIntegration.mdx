import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Email Integration" />

# Email Integration (Gmail)

project can ingest emails from Gmail as inbox items via the Gmail API.
Users connect their Gmail account in **Settings > Email**, and the system
syncs new messages into the inbox for triage — near-instantly via Pub/Sub
push notifications, with periodic polling as a reconciliation fallback.

Archive actions are **bidirectional**: archiving a gmail item in TAY removes
it from the Gmail inbox, and archiving an email in Gmail archives the
corresponding item in TAY.

> **Status**: The Gmail API integration is fully tested end-to-end —
> OAuth flow, incremental sync, push notifications, bidirectional archive,
> and reconnection after disconnect have all been validated in production.

---

## OAuth Flow

The OAuth flow uses a **popup window** to avoid navigating the user away from
the app. After Google consent completes, the popup posts a message back to the
opener and closes itself.

```
User clicks "Mit Google verbinden" in Settings > Email
  → Frontend opens popup: GET /email/oauth/gmail/authorize
  → Backend returns Google consent URL (signed state JWT)
  → Popup redirects to Google consent screen
  → User grants access
  → Google redirects to GMAIL_REDIRECT_URI (backend callback)
  → Backend exchanges code for tokens, encrypts + stores them
  → Backend redirects popup to FRONTEND_BASE_URL?gmail=connected
  → Popup detects query param, posts message to opener, closes
  → Parent window receives message, refetches connections,
    navigates to Settings > Email tab
```

If the popup is blocked by the browser, the flow falls back to a full-page
redirect. The parent window detects `?gmail=connected` on mount and navigates
to the email settings tab.

### Disconnect and Reconnect

When a user disconnects their Gmail account (Settings > Email > "Verbindung trennen"):

1. Gmail Watch is stopped (Pub/Sub notifications cease)
2. Connection is soft-deleted: `is_active = false`, tokens wiped, `archived_at` set
3. **Existing synced items are preserved** — they stay in their current buckets
4. The `email_sync_state` (history checkpoint) is preserved

When reconnecting the same email address:

1. The existing connection row is reactivated (not duplicated)
2. New OAuth tokens are stored, `is_active = true`, `archived_at` cleared
3. Gmail Watch is re-registered for push notifications
4. First sync resumes from the preserved `last_history_id`:
   - If history is still valid (`<7 days`): incremental sync catches up
   - If history expired (`>7 days`): full-sync fallback with reconciliation

---

## Sync Strategy

### Primary: Gmail API Watch + Pub/Sub Pull (~5-10s latency)

Gmail's `users.watch()` API registers push notifications for a user's mailbox.
When a change occurs, Google publishes to a Cloud Pub/Sub topic. A dedicated
**watch worker** process pulls from the subscription and enqueues sync jobs.

```
Gmail mailbox change
  → Google publishes to Pub/Sub topic
  → Watch worker pulls from subscription (every 5s)
  → Enqueues email_sync_job outbox event
  → Projection worker picks up event (within 1s)
  → run_email_sync() uses Gmail API
  → history.list → messages.get → transform → upsert items
```

The watch worker (`python -m app.email.watch_worker --loop`) runs as a
separate process alongside the projection worker. It is included in `npm run dev`
(`dev:stack`) and starts automatically. It groups notifications by email address,
deduplicates, and enqueues one `email_sync_job` per account.

In Kubernetes production, `watch-worker` is deployed by default and mounts the
`pubsub-sa` service account secret at `/etc/gcp/pubsub-sa.json`.

**Startup behavior**: On startup, the watch worker automatically registers watches
for any active connections that don't have one yet (`register_missing_watches()`).
This means connections created before Pub/Sub was configured get watches
automatically — no need to disconnect and reconnect Gmail.

Gmail watches expire after ~7 days. The watch worker periodically checks for
expiring watches (within 12 hours of expiry) and renews them automatically.

**Auto-detection**: Pub/Sub is enabled when all three required env vars are set:
`GMAIL_PUBSUB_PROJECT_ID`, `GMAIL_PUBSUB_SUBSCRIPTION`, and
`GMAIL_PUBSUB_CREDENTIALS_FILE`. There is no separate feature flag — if the
config is present, watch is active. If not, the watch worker exits gracefully.

The Settings UI shows the current sync method: **"Echtzeit-Sync (Push)"** when
watch is active, or **"Polling alle X Min."** when falling back to polling only.

### Startup Sync

On every restart, the projection worker immediately enqueues sync jobs for
**all active email connections** via `enqueue_all_active_syncs()`, regardless of
when the last sync ran. This ensures new emails appear in the inbox within
seconds of `npm run dev`.

### Fallback: Periodic Polling (every 5 min)

As a reconciliation safety net, the projection worker calls `enqueue_due_syncs()`
every 5 minutes. This catches cases where a Pub/Sub notification was missed
or the watch worker was temporarily down.

### Sync Process

Each `email_sync_job` triggers `run_email_sync()`:

1. Load connection + refresh OAuth token if expired
2. Incremental sync via `gmail_api.history_list(start_history_id)` — fetches
   both `messageAdded` and `labelRemoved` events since the last checkpoint
3. For each new message (`messageAdded`): `gmail_api.message_get()` → parse
   headers/body → `build_email_item()` → upsert as `@type: "EmailMessage"`
4. For each archived message (`labelRemoved` with INBOX): find the
   corresponding TAY item and set `archived_at`
5. Update `last_history_id` checkpoint in `email_sync_state`
6. Optionally mark fetched messages as read via
   `gmail_api.message_modify(remove_label_ids=["UNREAD"])`

If the history ID has expired (Gmail returns 404), the sync falls back to
`gmail_api.messages_list(query="in:inbox newer_than:7d")` and resets the
history checkpoint. During this full-sync fallback, **reconciliation** runs
automatically: active TAY items whose Gmail messages are no longer in the
inbox get archived.

### Bidirectional Archive

Archive actions sync in both directions:

| Direction | Trigger | Mechanism |
|-----------|---------|-----------|
| **TAY → Gmail** | User archives a gmail item in TAY | Worker calls `sync_email_archive()` → `gmail_api.message_modify(remove_label_ids=["UNREAD", "INBOX"])` |
| **Gmail → TAY** | User archives an email in Gmail | Next sync detects `labelsRemoved` (INBOX) in history → sets `archived_at` on corresponding TAY item |

**Loop prevention**: When TAY archives an item, the Gmail label change appears
in the next sync's history. The sync sees the item is already archived
(`WHERE archived_at IS NULL` returns 0 rows) and skips it. Similarly, Gmail's
`message_modify` is idempotent — removing INBOX from a message without INBOX
is a no-op.

**Reconciliation**: During full-sync fallback (history expired), the sync
cross-checks all active TAY gmail items against the current Gmail inbox. Items
no longer in the inbox get archived. This handles connectivity gaps longer than
7 days where history events were lost.

---

## Setup

### 1. Create Google Cloud OAuth Credentials

1. Go to [Google Cloud Console > Credentials](https://console.cloud.google.com/apis/credentials)
2. Click **Create Credentials > OAuth client ID**
3. Application type: **Web application**
4. Add **Authorized redirect URIs** for each environment:

| Environment | Redirect URI |
|-------------|-------------|
| Local dev (bare metal) | `http://localhost:8000/email/oauth/gmail/callback` |
| Local dev (K8s) | `http://localhost:8080/api/email/oauth/gmail/callback` |
| Production | `https://<your-domain>/api/email/oauth/gmail/callback` |

> In production the backend is behind an Nginx reverse proxy at `/api/`, so
> the public redirect URI includes the `/api` prefix even though the backend
> route is `/email/oauth/gmail/callback`.

5. Save and note the **Client ID** and **Client Secret**.

### 2. Set Up Pub/Sub (for real-time notifications)

> This step is optional. Without Pub/Sub, email sync falls back to periodic
> polling every 5 minutes (plus immediate sync on startup).

#### Automated Setup (Ansible)

An Ansible playbook creates all GCP resources idempotently — topic, subscription,
service account, IAM bindings, and credentials file:

```bash
ansible-playbook infra/gcp-pubsub.yml -e gcp_project=<your-gcp-project-id>
```

The playbook:
1. Creates the Pub/Sub topic (`gmail-push`)
2. Grants `gmail-api-push@system.gserviceaccount.com` Publisher role on the topic
3. Creates a pull subscription (`gmail-push-sub`) with 30s ack deadline
4. Creates a service account (`gmail-push-sub@<project>.iam.gserviceaccount.com`)
5. Grants Subscriber role on the subscription
6. Downloads the service account JSON key to `tmp/<project>-pubsub-sa.json`
7. Prints the `.env` variables to add

Re-run safely at any time — all tasks are idempotent.

#### Validation

Verify the configuration without making changes:

```bash
./scripts/validate-pubsub.sh
```

Checks: credentials file, topic exists, Gmail publisher IAM, subscription exists
and points to correct topic, service account subscriber IAM. Prints fix commands
for any failures.

#### Manual Setup

If you prefer manual setup or need to customize resource names:

1. Enable **Gmail API** and **Cloud Pub/Sub API** in GCP Console
2. Create a Pub/Sub topic:
   ```bash
   gcloud pubsub topics create gmail-push --project=<project>
   ```
3. Grant Gmail permission to publish to the topic:
   ```bash
   gcloud pubsub topics add-iam-policy-binding projects/<project>/topics/gmail-push \
     --member="serviceAccount:gmail-api-push@system.gserviceaccount.com" \
     --role="roles/pubsub.publisher" --project=<project>
   ```
4. Create a pull subscription:
   ```bash
   gcloud pubsub subscriptions create gmail-push-sub \
     --topic=gmail-push --ack-deadline=30 --project=<project>
   ```
5. Create a service account with **Pub/Sub Subscriber** role on the subscription
   and download the JSON key file
6. Set the `GMAIL_PUBSUB_*` env vars (see below) — no feature flag needed,
   Pub/Sub is auto-detected from config presence

### 3. Generate Encryption Keys

The backend encrypts OAuth tokens at rest using Fernet symmetric encryption,
and signs OAuth state parameters with a separate secret.

```bash
# Gmail state secret (CSRF protection for OAuth flow)
python -c "import secrets; print(secrets.token_urlsafe(32))"

# Fernet encryption key (token encryption at rest)
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

### 4. Environment Variables

#### Local Development (`.env`)

```bash
# Gmail OAuth
GMAIL_CLIENT_ID=<your-google-oauth-client-id>
GMAIL_CLIENT_SECRET=<your-google-oauth-client-secret>
GMAIL_REDIRECT_URI=http://localhost:8000/email/oauth/gmail/callback
GMAIL_STATE_SECRET=<generated-state-secret>

# Token encryption
ENCRYPTION_KEY=<generated-fernet-key>

# Frontend URL (OAuth callback redirects here after success)
FRONTEND_BASE_URL=http://localhost:5173

# Gmail Watch + Pub/Sub (optional — auto-detected when all vars are set)
GMAIL_PUBSUB_PROJECT_ID=<your-gcp-project-id>
GMAIL_PUBSUB_TOPIC=projects/<your-gcp-project-id>/topics/gmail-push
GMAIL_PUBSUB_SUBSCRIPTION=gmail-push-sub
GMAIL_PUBSUB_CREDENTIALS_FILE=tmp/<project>-pubsub-sa.json
```

#### Kubernetes Production

Non-secret values go in the **ConfigMap** (`infra/k8s/overlays/production/configmap.yaml`):

```yaml
GMAIL_REDIRECT_URI: "https://<your-domain>/api/email/oauth/gmail/callback"
FRONTEND_BASE_URL: "https://<your-domain>"
GMAIL_PUBSUB_PROJECT_ID: "<your-gcp-project-id>"
GMAIL_PUBSUB_TOPIC: "projects/<your-gcp-project-id>/topics/gmail-push"
GMAIL_PUBSUB_SUBSCRIPTION: "gmail-push-sub"
GMAIL_PUBSUB_CREDENTIALS_FILE: "/etc/secrets/pubsub/credentials.json"
```

Secret values go in the **`app-secrets` Secret** (managed by ops, not in version control):

```bash
kubectl -n <namespace> patch secret app-secrets --type merge -p '{
  "stringData": {
    "GMAIL_CLIENT_ID": "<your-google-oauth-client-id>",
    "GMAIL_CLIENT_SECRET": "<your-google-oauth-client-secret>",
    "GMAIL_STATE_SECRET": "<generated-state-secret>",
    "ENCRYPTION_KEY": "<generated-fernet-key>"
  }
}'
```

Then restart the backend deployment to pick up the new values:

```bash
kubectl -n <namespace> rollout restart deployment/backend deployment/worker deployment/watch-worker
```

---

## Scopes

The integration requests the `https://mail.google.com/` scope which covers
both Gmail API access and IMAP (legacy fallback). The scope can be customized
via the `GMAIL_SCOPES` environment variable.

---

## Architecture

### Backend Components

| Module | Purpose |
|--------|---------|
| `app/email/routes.py` | OAuth endpoints (`/authorize`, `/callback`) + connection CRUD + sync trigger |
| `app/email/gmail_oauth.py` | Google OAuth helpers (auth URL, code exchange, token refresh) |
| `app/email/gmail_api.py` | Gmail REST API v1 client (history, messages, watch, modify) |
| `app/email/sync.py` | Sync orchestrator (Gmail API history → parse → upsert → archive) + watch lifecycle + reconciliation |
| `app/email/transform.py` | EmailMessage dataclass + `build_email_item()` JSON-LD transform |
| `app/email/pubsub.py` | Pub/Sub pull client (service account auth, message parsing) |
| `app/email/watch_worker.py` | Dedicated Pub/Sub pull loop process (started by `dev:stack`) |
| `app/email/imap_client.py` | Generic IMAP client (see IMAP section below) |
| `app/crypto.py` | Fernet encryption/decryption for OAuth tokens at rest |

### Infrastructure

| File | Purpose |
|------|---------|
| `infra/gcp-pubsub.yml` | Ansible playbook — creates topic, subscription, SA, IAM bindings |
| `scripts/validate-pubsub.sh` | Validates Pub/Sub config (credentials, topic, subscription, IAM) |
| `scripts/start_watch_worker.sh` | Watch worker startup script (used by `dev:stack`) |

### Frontend Components

| Component | Purpose |
|-----------|---------|
| `EmailPanel` | Settings tab — connect button, connection list, sync controls |
| `EmailConnectionCard` | Individual connection display with sync method indicator, sync/disconnect actions |
| `EmailBodyViewer` | Inline email body display in ActionRow (sanitized HTML via DOMPurify) |

### Test Coverage

| Test File | Scope |
|-----------|-------|
| `backend/tests/test_email_sync.py` | Sync orchestrator: message parsing, incremental sync, full-sync fallback, reverse archive, reconciliation |
| `backend/tests/test_email_worker.py` | Worker event handlers: sync job dispatch, TAY→Gmail archive, polling scheduler |
| `backend/tests/test_watch_worker.py` | Pub/Sub notification processing, watch renewal |
| `frontend/.../EmailConnectionCard.test.tsx` | Connection card UI: status badge, sync method indicator, actions |
| `frontend/.../EmailPanel.test.tsx` | Panel: empty state, loading, connection list, callbacks |

---

## IMAP (Generic Providers)

> **Not end-to-end tested.** The IMAP client (`app/email/imap_client.py`) was
> ported from the Procedere prototype and provides OAuth2-based IMAP access
> for Gmail. It is **not currently used** — Gmail email ingestion uses the
> REST API exclusively. The IMAP client is kept as a foundation for future
> non-Gmail IMAP providers (e.g. Outlook, corporate IMAP servers) but has
> not been validated in an integration or production setting.

### What exists

- `ImapClient` class with OAuth2 XOAUTH2 authentication (no password auth)
- `fetch_since(since_uid)` — incremental fetch by UID range
- `fetch_all()` — full INBOX fetch
- Message parsing: headers, plain text body, HTML body, attachments
- Returns `EmailMessage` dataclass (same as Gmail API path)

### What is missing for production use

- No connection management UI (Settings only supports Gmail OAuth)
- No sync orchestrator integration (only Gmail's `run_email_sync` is wired)
- No automated tests (unit or integration)
- No IDLE/push notification support (would need a dedicated worker)
- No provider-specific OAuth flows (Outlook, Yahoo, etc.)
- No IMAP-specific error handling or retry logic

### When to revisit

If a second email provider is needed, the recommended approach is:

1. Add provider-specific OAuth flow in `routes.py`
2. Wire `ImapClient` into a new `run_imap_sync()` function in `sync.py`
3. Add end-to-end tests with a test IMAP server (e.g. GreenMail)
4. Validate the full cycle: connect → sync → archive → disconnect → reconnect

---

## Troubleshooting

| Symptom | Cause | Fix |
|---------|-------|-----|
| "Gmail OAuth not configured" (HTTP 500) | `GMAIL_CLIENT_ID` or `GMAIL_CLIENT_SECRET` empty | Set credentials in `.env` or `app-secrets` |
| "redirect_uri_mismatch" from Google | Redirect URI not registered in Cloud Console | Add the exact URI to Authorized redirect URIs |
| Token exchange fails (HTTP 502) | Wrong `GMAIL_CLIENT_SECRET` or expired code | Verify credentials; re-initiate OAuth |
| "Invalid state" (HTTP 400) | `GMAIL_STATE_SECRET` changed between authorize and callback | Ensure secret is stable across backend restarts |
| Decryption errors on sync | `ENCRYPTION_KEY` changed after tokens were stored | Tokens must be re-authorized with new key |
| "internal_failure" from Google | OAuth consent screen in "Testing" mode; user not in test list | Add your Google account to test users, or publish the app |
| Stale items after reconnect | History expired during disconnect period (>7 days) | Full-sync fallback + reconciliation handles this automatically |
| Archive not syncing to Gmail | Check worker logs for `sync_email_archive:` entries | Verify connection is active, token valid, gmailMessageId present |
| Watch worker exits immediately | Pub/Sub env vars not set | Set `GMAIL_PUBSUB_PROJECT_ID`, `GMAIL_PUBSUB_SUBSCRIPTION`, `GMAIL_PUBSUB_CREDENTIALS_FILE`; or run `ansible-playbook infra/gcp-pubsub.yml` |
| Watch worker auth error | Service account missing Subscriber role | Run `./scripts/validate-pubsub.sh` and apply suggested fix commands |
| Push notifications not arriving | Gmail can't publish to topic | Verify `gmail-api-push@system.gserviceaccount.com` has Publisher role: `./scripts/validate-pubsub.sh` |
| No emails on restart | Startup sync didn't trigger | Check worker logs for `enqueue_all_active_syncs`; verify active connection exists |

---

## Related Documentation

- [Deployment](?path=/docs/engineering-deployment--docs) — GitOps pipeline, K8s secrets reference
- [Backend Architecture](?path=/docs/engineering-backend-architecture--docs) — API structure, worker system
