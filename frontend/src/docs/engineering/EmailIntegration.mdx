import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Email Integration" />

# Email Integration (Gmail)

TerminAndoYo can ingest emails from Gmail as inbox items via the Gmail API.
Users connect their Gmail account in **Settings > Email**, and the system
syncs new messages into the inbox for triage — near-instantly via Pub/Sub
push notifications, with periodic polling as a reconciliation fallback.

---

## OAuth Flow

The OAuth flow uses a **popup window** to avoid navigating the user away from
the app. After Google consent completes, the popup posts a message back to the
opener and closes itself.

```
User clicks "Mit Google verbinden" in Settings > Email
  → Frontend opens popup: GET /email/oauth/gmail/authorize
  → Backend returns Google consent URL (signed state JWT)
  → Popup redirects to Google consent screen
  → User grants access
  → Google redirects to GMAIL_REDIRECT_URI (backend callback)
  → Backend exchanges code for tokens, encrypts + stores them
  → Backend redirects popup to FRONTEND_BASE_URL?gmail=connected
  → Popup detects query param, posts message to opener, closes
  → Parent window receives message, refetches connections,
    navigates to Settings > Email tab
```

If the popup is blocked by the browser, the flow falls back to a full-page
redirect. The parent window detects `?gmail=connected` on mount and navigates
to the email settings tab.

---

## Sync Strategy

### Primary: Gmail API Watch + Pub/Sub Pull (~5-10s latency)

Gmail's `users.watch()` API registers push notifications for a user's mailbox.
When a change occurs, Google publishes to a Cloud Pub/Sub topic. A dedicated
**watch worker** process pulls from the subscription and enqueues sync jobs.

```
Gmail mailbox change
  → Google publishes to Pub/Sub topic
  → Watch worker pulls from subscription (every 5s)
  → Enqueues email_sync_job outbox event
  → Projection worker picks up event (within 1s)
  → run_email_sync() uses Gmail API
  → history.list → messages.get → transform → upsert items
```

The watch worker (`python -m app.email.watch_worker --loop`) runs as a
separate process alongside the projection worker. It groups notifications by
email address, deduplicates, and enqueues one `email_sync_job` per account.

Gmail watches expire after ~7 days. The watch worker periodically checks for
expiring watches (within 12 hours of expiry) and renews them automatically.

### Fallback: Periodic Polling (every 5 min)

As a reconciliation safety net, the projection worker calls `enqueue_due_syncs()`
every 5 minutes. This catches cases where a Pub/Sub notification was missed
or the watch worker was temporarily down.

### Sync Process

Each `email_sync_job` triggers `run_email_sync()`:

1. Load connection + refresh OAuth token if expired
2. Incremental sync via `gmail_api.history_list(start_history_id)` — fetches
   only changes since the last checkpoint
3. For each new message: `gmail_api.message_get()` → parse headers/body →
   `build_email_item()` → upsert as `@type: "EmailMessage"`
4. Update `last_history_id` checkpoint in `email_sync_state`
5. Optionally mark fetched messages as read via
   `gmail_api.message_modify(remove_label_ids=["UNREAD"])`

If the history ID has expired (Gmail returns 404), the sync falls back to
`gmail_api.messages_list(query="in:inbox newer_than:7d")` and resets the
history checkpoint.

### Mark-as-Read on Archive

When a gmail-sourced item is archived (triaged out of inbox), the projection
worker calls `mark_email_read()` which uses `gmail_api.message_modify()` to
remove the `UNREAD` label in Gmail. The `gmailMessageId` is stored in
`sourceMetadata.raw` during sync for this purpose.

---

## Setup

### 1. Create Google Cloud OAuth Credentials

1. Go to [Google Cloud Console > Credentials](https://console.cloud.google.com/apis/credentials)
2. Click **Create Credentials > OAuth client ID**
3. Application type: **Web application**
4. Add **Authorized redirect URIs** for each environment:

| Environment | Redirect URI |
|-------------|-------------|
| Local dev (bare metal) | `http://localhost:8000/email/oauth/gmail/callback` |
| Local dev (K8s) | `http://localhost:8080/api/email/oauth/gmail/callback` |
| Production | `https://<your-domain>/api/email/oauth/gmail/callback` |

> In production the backend is behind an Nginx reverse proxy at `/api/`, so
> the public redirect URI includes the `/api` prefix even though the backend
> route is `/email/oauth/gmail/callback`.

5. Save and note the **Client ID** and **Client Secret**.

### 2. Set Up Pub/Sub (for real-time notifications)

> This step is optional. Without Pub/Sub, email sync falls back to periodic
> polling every 5 minutes.

1. Enable **Gmail API** and **Cloud Pub/Sub API** in GCP Console
2. Create a Pub/Sub topic:
   ```bash
   gcloud pubsub topics create gmail-notifications
   ```
3. Grant Gmail permission to publish to the topic:
   ```bash
   gcloud pubsub topics add-iam-policy-binding gmail-notifications \
     --member="serviceAccount:gmail-api-push@system.gserviceaccount.com" \
     --role="roles/pubsub.publisher"
   ```
4. Create a pull subscription:
   ```bash
   gcloud pubsub subscriptions create gmail-notifications-pull \
     --topic=gmail-notifications --ack-deadline=60
   ```
5. Create a service account with **Pub/Sub Subscriber** role and download
   the JSON key file
6. Set `GMAIL_WATCH_ENABLED=true` and the `GMAIL_PUBSUB_*` env vars (see below)

### 3. Generate Encryption Keys

The backend encrypts OAuth tokens at rest using Fernet symmetric encryption,
and signs OAuth state parameters with a separate secret.

```bash
# Gmail state secret (CSRF protection for OAuth flow)
python -c "import secrets; print(secrets.token_urlsafe(32))"

# Fernet encryption key (token encryption at rest)
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

### 4. Environment Variables

#### Local Development (`.env`)

```bash
# Gmail OAuth
GMAIL_CLIENT_ID=<your-google-oauth-client-id>
GMAIL_CLIENT_SECRET=<your-google-oauth-client-secret>
GMAIL_REDIRECT_URI=http://localhost:8000/email/oauth/gmail/callback
GMAIL_STATE_SECRET=<generated-state-secret>

# Token encryption
ENCRYPTION_KEY=<generated-fernet-key>

# Frontend URL (OAuth callback redirects here after success)
FRONTEND_BASE_URL=http://localhost:5173

# Gmail Watch + Pub/Sub (optional — enables real-time sync)
GMAIL_WATCH_ENABLED=false
GMAIL_PUBSUB_PROJECT_ID=<your-gcp-project-id>
GMAIL_PUBSUB_TOPIC=gmail-notifications
GMAIL_PUBSUB_SUBSCRIPTION=gmail-notifications-pull
GMAIL_PUBSUB_CREDENTIALS_FILE=/path/to/service-account.json
```

#### Kubernetes Production

Non-secret values go in the **ConfigMap** (`infra/k8s/overlays/production/configmap.yaml`):

```yaml
GMAIL_REDIRECT_URI: "https://<your-domain>/api/email/oauth/gmail/callback"
FRONTEND_BASE_URL: "https://<your-domain>"
GMAIL_WATCH_ENABLED: "true"
GMAIL_PUBSUB_PROJECT_ID: "<your-gcp-project-id>"
GMAIL_PUBSUB_TOPIC: "gmail-notifications"
GMAIL_PUBSUB_SUBSCRIPTION: "gmail-notifications-pull"
GMAIL_PUBSUB_CREDENTIALS_FILE: "/etc/secrets/pubsub/credentials.json"
```

Secret values go in the **`app-secrets` Secret** (managed by ops, not in version control):

```bash
kubectl -n <namespace> patch secret app-secrets --type merge -p '{
  "stringData": {
    "GMAIL_CLIENT_ID": "<your-google-oauth-client-id>",
    "GMAIL_CLIENT_SECRET": "<your-google-oauth-client-secret>",
    "GMAIL_STATE_SECRET": "<generated-state-secret>",
    "ENCRYPTION_KEY": "<generated-fernet-key>"
  }
}'
```

Then restart the backend deployment to pick up the new values:

```bash
kubectl -n <namespace> rollout restart deployment/backend deployment/worker deployment/watch-worker
```

---

## Scopes

The integration requests the `https://mail.google.com/` scope which covers
both Gmail API access and IMAP (legacy fallback). The scope can be customized
via the `GMAIL_SCOPES` environment variable.

---

## Architecture

### Backend Components

| Module | Purpose |
|--------|---------|
| `app/email/routes.py` | OAuth endpoints (`/authorize`, `/callback`) + connection CRUD + sync trigger |
| `app/email/gmail_oauth.py` | Google OAuth helpers (auth URL, code exchange, token refresh) |
| `app/email/gmail_api.py` | Gmail REST API v1 client (history, messages, watch, modify) |
| `app/email/sync.py` | Sync orchestrator (Gmail API history → parse → upsert) + watch lifecycle |
| `app/email/transform.py` | EmailMessage dataclass + `build_email_item()` JSON-LD transform |
| `app/email/pubsub.py` | Pub/Sub pull client (service account auth, message parsing) |
| `app/email/watch_worker.py` | Dedicated Pub/Sub pull loop process |
| `app/email/imap_client.py` | IMAP client (kept for future non-Gmail IMAP providers; currently unused) |
| `app/crypto.py` | Fernet encryption/decryption for OAuth tokens at rest |

### Frontend Components

| Component | Purpose |
|-----------|---------|
| `EmailPanel` | Settings tab — connect button, connection list, sync controls |
| `EmailConnectionCard` | Individual connection display with sync/disconnect actions |
| `EmailBodyViewer` | Inline email body display in ActionRow (sanitized HTML via DOMPurify) |

---

## Troubleshooting

| Symptom | Cause | Fix |
|---------|-------|-----|
| "Gmail OAuth not configured" (HTTP 500) | `GMAIL_CLIENT_ID` or `GMAIL_CLIENT_SECRET` empty | Set credentials in `.env` or `app-secrets` |
| "redirect_uri_mismatch" from Google | Redirect URI not registered in Cloud Console | Add the exact URI to Authorized redirect URIs |
| Token exchange fails (HTTP 502) | Wrong `GMAIL_CLIENT_SECRET` or expired code | Verify credentials; re-initiate OAuth |
| "Invalid state" (HTTP 400) | `GMAIL_STATE_SECRET` changed between authorize and callback | Ensure secret is stable across backend restarts |
| Decryption errors on sync | `ENCRYPTION_KEY` changed after tokens were stored | Tokens must be re-authorized with new key |
| "internal_failure" from Google | OAuth consent screen in "Testing" mode; user not in test list | Add your Google account to test users, or publish the app |

---

## Related Documentation

- [Deployment](?path=/docs/engineering-deployment--docs) — GitOps pipeline, K8s secrets reference
- [Backend Architecture](?path=/docs/engineering-backend-architecture--docs) — API structure, worker system
