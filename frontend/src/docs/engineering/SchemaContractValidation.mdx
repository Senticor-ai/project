import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Ontology/Schema Contract Validation" />

# Schema Contract Validation

The backend Pydantic models in `backend/app/models.py` are the **single source of truth**
for JSON-LD payload shapes. Schemas are generated at runtime and served via API —
no static files to keep in sync. The frontend validates serializer output against
these schemas at test time using AJV.

---

## Architecture

```
backend/app/models.py              Pydantic models (source of truth)
        │
        ▼
GET /schemas/{name}                JSON Schema (application/schema+json)
        │
        ▼
schema-validator.ts                fetch + AJV compile
        │
        ▼
item-serializer.test.ts            10 contract tests (skip if backend unreachable)
```

---

## Backend API

The `/schemas` endpoints are served by `backend/app/routes/schemas.py`.
Full OpenAPI documentation is available at [`/docs`](http://localhost:8000/docs)
under the **schemas** tag.

| Endpoint              | Response                                | Description                            |
| --------------------- | --------------------------------------- | -------------------------------------- |
| `GET /schemas`        | `{ "schemas": ["action-item", ...] }`   | List all available schema names        |
| `GET /schemas/{name}` | JSON Schema (`application/schema+json`) | Full schema for a specific entity type |

### Available schemas

| Schema name      | Pydantic model        | Purpose                                                 |
| ---------------- | --------------------- | ------------------------------------------------------- |
| `action-item`    | `ActionItemJsonLd`    | Inbox/next/waiting/calendar/someday (`@type: "Action"`) |
| `project-item`   | `ProjectItemJsonLd`   | Multi-step outcome (`@type: "Project"`)                 |
| `reference-item` | `ReferenceItemJsonLd` | Reference material (`@type: "CreativeWork"`)            |
| `item-patch`     | `ItemPatchModel`      | Partial JSON-LD for PATCH deep-merge                    |
| `property-value` | `PropertyValueModel`  | `additionalProperty` entry shape                        |

Schemas are generated from `model.model_json_schema(by_alias=True, mode="serialization")`,
so they always reflect the exact Pydantic model that validates incoming requests.

---

## Action Subtype Validation

Action items (`@type: "Action"`) support **semantic subtypes** via the `additionalType` field.
Each subtype corresponds to a specific schema.org action type and must be validated against
its corresponding Pydantic model in `backend/app/models.py`.

### Available action subtypes

| Subtype             | Schema.org Type     | Purpose                    | Pydantic Model            |
| ------------------- | ------------------- | -------------------------- | ------------------------- |
| `InformAction`      | `InformAction`      | Notify, announce, report   | `InformActionJsonLd`      |
| `OrganizeAction`    | `OrganizeAction`    | Arrange, plan, schedule    | `OrganizeActionJsonLd`    |
| `CommunicateAction` | `CommunicateAction` | Call, email, discuss       | `CommunicateActionJsonLd` |
| `ConsumeAction`     | `ConsumeAction`     | Read, review documents     | `ConsumeActionJsonLd`     |
| `AssessAction`      | `AssessAction`      | Evaluate, decide, judge    | `AssessActionJsonLd`      |
| `ReviewAction`      | `ReviewAction`      | Review, check, validate    | `ReviewActionJsonLd`      |
| `CreateAction`      | `CreateAction`      | Write, draft, create       | `CreateActionJsonLd`      |
| `InteractAction`    | `InteractAction`    | Meet, present, collaborate | `InteractActionJsonLd`    |

### Validation rules

1. **Type hierarchy**: All subtypes inherit from `ActionItemJsonLd` and must include both:
   - `@type: "Action"` (base type)
   - `additionalType: "https://schema.org/{SubtypeName}"` (semantic subtype)

2. **Required fields**: Each subtype extends the base action schema with subtype-specific fields:
   - `InformAction`: `recipient` (Person or Organization)
   - `CommunicateAction`: `recipient` (Person or Organization)
   - `AssessAction`: `object` (Thing being assessed)
   - `ReviewAction`: `itemReviewed` (Thing being reviewed)

3. **Backend validation**: The backend uses Pydantic discriminated unions to validate subtypes:

   ```python
   ActionItemJsonLd = Annotated[
       Union[
           InformActionJsonLd,
           OrganizeActionJsonLd,
           # ... other subtypes
       ],
       Field(discriminator="additional_type")
   ]
   ```

4. **Frontend serialization**: `item-serializer.ts` must set both `@type` and `additionalType`:
   ```typescript
   {
     "@type": "Action",
     "additionalType": "https://schema.org/InformAction",
     // ... other fields
   }
   ```

### Schema endpoint behavior

When fetching schemas for subtypes:

- `GET /schemas/action-item` returns the **discriminated union schema** with all subtype variants
- Each variant in `oneOf` corresponds to one subtype's Pydantic model
- AJV validates by testing each `oneOf` branch until one matches

---

## Frontend Validation Helper

**File**: `frontend/src/lib/__tests__/schema-validator.ts`

The helper fetches schemas from the backend API and compiles AJV validators:

```typescript
import {
  loadValidators,
  isBackendAvailable,
  formatErrors,
} from "./__tests__/schema-validator";

// Check connectivity (2 s timeout)
const backendUp = await isBackendAvailable();

// Fetch and compile all 5 entity validators
const validators = await loadValidators();

// Validate a payload
const valid = validators.validateInboxItem(payload);
if (!valid) console.error(formatErrors(validators.validateInboxItem));
```

| Export                   | Purpose                                                     |
| ------------------------ | ----------------------------------------------------------- |
| `isBackendAvailable()`   | Probe `GET /schemas` with a 2 s timeout                     |
| `loadValidators()`       | Fetch all 5 schemas, return compiled `ValidateFunction` map |
| `formatErrors(validate)` | Convert AJV errors to a readable string                     |

The backend URL defaults to `http://localhost:8000` and can be overridden
via `VITE_API_BASE_URL`.

---

## Contract Tests

**File**: `frontend/src/lib/item-serializer.test.ts` — `describe("JSON Schema contract validation")`

Ten tests validate that every `build*` and `toJsonLd` output conforms to the
corresponding backend schema. Tests skip gracefully when the backend is unreachable.

### Test matrix

| Test                                    | Validates against |
| --------------------------------------- | ----------------- |
| `buildNewInboxJsonLd`                   | `inbox-item`      |
| `buildNewActionJsonLd`                  | `action-item`     |
| `buildNewActionJsonLd` (with projectId) | `action-item`     |
| `buildNewReferenceJsonLd`               | `reference-item`  |
| `toJsonLd` (inbox item)                 | `inbox-item`      |
| `toJsonLd` (action)                     | `action-item`     |
| `toJsonLd` (project)                    | `project-item`    |
| `toJsonLd` (reference)                  | `reference-item`  |
| `buildTriagePatch`                      | `item-patch`      |
| `buildItemEditPatch`                    | `item-patch`      |

### Skip pattern

Tests use the Vitest `skip` context to bail out when the backend is down:

```typescript
describe("JSON Schema contract validation", () => {
  let validators: SchemaValidators;
  let backendUp: boolean;

  beforeAll(async () => {
    backendUp = await isBackendAvailable();
    if (backendUp) {
      validators = await loadValidators();
    }
  });

  it("buildNewInboxJsonLd → inbox-item schema", ({ skip }) => {
    if (!backendUp) skip();
    const ld = buildNewInboxJsonLd("Anruf bei Frau Müller");
    const valid = validators.validateInboxItem(ld);
    expect(valid, formatErrors(validators.validateInboxItem)).toBe(true);
  });
});
```

This means `CI=1 npx vitest run --project=unit` always passes —
contract tests report as **skipped** without a running backend,
and **fail loudly** when the backend is up and the schema has drifted.

---

## Workflow: When Backend Models Change

1. Edit Pydantic models in `backend/app/models.py`
2. Restart the backend (`uvicorn app.main:app --reload`)
3. Run frontend contract tests: `cd frontend && CI=1 npx vitest run --project=unit`
4. If a serializer test fails, update `item-serializer.ts` to match the new schema
5. Commit both backend and frontend changes together

No regeneration step, no static files, no drift detection scripts.
The contract tests are the enforcement mechanism.

---

## See also

- [Ontology Overview](?path=/docs/engineering-ontology--docs) — Core data model and entity types
- [Schema.org Vocabulary](?path=/docs/engineering-ontology-schema-org-vocabulary--docs) — Full catalog of schema.org types
- [Backend API Requests](?path=/docs/engineering-backend-api-requests-import-ux--docs) — Endpoint documentation and import UX
