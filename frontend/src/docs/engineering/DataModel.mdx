import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Ontology" />

# Overview

The core data model lives in `frontend/src/model/` and uses **schema.org as the primary ontology**.
App-specific concepts that have no schema.org equivalent use `additionalProperty`
([PropertyValue](https://schema.org/PropertyValue)) to stay within the schema.org vocabulary.

**Deep dives:**

| Page | Scope |
| --- | --- |
| [Schema.org Vocabulary](?path=/docs/engineering-ontology-schema-org-vocabulary--docs) | Full catalog of schema.org types available to the app |
| [FRBR Knowledge Graph](?path=/docs/engineering-ontology-frbr-knowledge-graph--docs) | Document hierarchy for the knowledge graph projection |
| [LexCEL Architecture](?path=/docs/engineering-ontology-lexcel-architecture--docs) | Typed references, ports, and rule layer |
| [Legal Reference Normalization](?path=/docs/engineering-ontology-legal-reference-normalization--docs) | Citation parsing and normalization |

---

## Schema.org-First Principle

Every entity is stored as **JSON-LD** using a schema.org `@type`. Custom fields that have no schema.org equivalent
go into `additionalProperty` as `PropertyValue` objects rather than inventing a parallel type system.

**Why?** Schema.org is the most widely adopted structured data vocabulary. Using it as
the primary ontology makes the data self-describing, interoperable, and queryable by
any tool that understands schema.org — including search engines, knowledge graphs, and LLMs.

**Rule of thumb:** If schema.org has a property for it, use the schema.org property.
Only use `additionalProperty` when schema.org genuinely has no equivalent.

---

## Everything is a Thing

Every item that is loaded, entered, or created starts as a `schema:Thing` — the most
generic type in schema.org. As the user or the system adds attributes, the `@type`
**specializes** to a more specific schema.org type:

```
Thing (base)
  → Action     (when it gets contexts, due dates, delegation, etc.)
  → Project    (when it gets a desired outcome and child actions)
  → CreativeWork  (when it gets a URL, file, or content type)
  → Event      (when it gets a date/time and duration)
```

Type detection can happen at any point:

- **At capture:** A user pastes a URL → the system can immediately set `@type: "CreativeWork"` with a `url` property. No triage needed.
- **During triage:** The user decides "this is something I need to do" → `@type` becomes `"Action"`.
- **Through enrichment:** An AI or the user adds attributes that make a more specific type appropriate.

### Inbox is a view, not a type

The **inbox** is a logical filter — it shows Things that have not yet been enriched beyond
the minimum text the user entered. There is no `InboxItem` type. Inbox items are simply
Things where `app:bucket = "inbox"` and typically `needsEnrichment = true`.

A Thing in the inbox might already have a specific `@type` if the system can detect it.
For example, dropping a PDF file creates a `CreativeWork` that still sits in the inbox
bucket until the user decides where it belongs.

### Type specialization summary

| `@type` | When it applies | Bucket(s) |
| --- | --- | --- |
| `Thing` | Default — not yet enriched, or genuinely generic | `inbox` (typically) |
| `Action` | Has actionable attributes (context, schedule, delegation) | `next` / `waiting` / `calendar` / `someday` |
| `Project` | Has a desired outcome and contains child actions | `project` |
| `CreativeWork` | Has a URL, file, or content type | `reference` (or `inbox` before triage) |
| `Event` | Has a specific date/time and duration | `calendar` |

---

## Canonical IDs

**File**: `frontend/src/model/canonical-id.ts`

Every entity gets a stable URN-style identifier:

```
urn:app:{entity-type}:{uuid}
```

| Entity Type | Example |
| --- | --- |
| `inbox` | `urn:app:inbox:a1b2c3d4-...` |
| `action` | `urn:app:action:e5f6a7b8-...` |
| `project` | `urn:app:project:c3d4e5f6-...` |
| `reference` | `urn:app:reference:b8c9d0e1-...` |
| `context` | `urn:app:context:c9d0e1f2-...` |
| `tag` | `urn:app:tag:d0e1f2a3-...` |

### API

```typescript
createCanonicalId("inbox", "abc-123"); // → "urn:app:inbox:abc-123"
parseCanonicalId("urn:app:project:xyz"); // → { entityType: "project", uuid: "xyz" }
```

---

## Property Mapping

### Direct schema.org properties

These map 1:1 to schema.org and appear as flat fields on the JSON-LD object:

| Frontend field | JSON-LD property | schema.org type | Notes |
| --- | --- | --- | --- |
| `name` | `name` | [name](https://schema.org/name) | Optional for Thing/Action; required for Project, ReferenceMaterial, Context |
| `description` | `description` | [description](https://schema.org/description) | All entities |
| `tags` | `keywords` | [keywords](https://schema.org/keywords) | Array of strings |
| `provenance.createdAt` | `dateCreated` | [dateCreated](https://schema.org/dateCreated) | ISO 8601 |
| `provenance.updatedAt` | `dateModified` | [dateModified](https://schema.org/dateModified) | ISO 8601 |
| `scheduledDate` | `startTime` | [startTime](https://schema.org/startTime) | Actions (schema.org Action property) |
| `completedAt` | `endTime` | [endTime](https://schema.org/endTime) | Completed Actions and Projects |
| `url` | `url` | [url](https://schema.org/url) | CreativeWork |
| `encodingFormat` | `encodingFormat` | [encodingFormat](https://schema.org/encodingFormat) | MIME type |
| `projectId` | `isPartOf` | [isPartOf](https://schema.org/isPartOf) | Action → Project |
| `actionIds` | `hasPart` | [hasPart](https://schema.org/hasPart) | Project → Actions |

### Custom via `additionalProperty`

These have no schema.org equivalent and are stored as `PropertyValue` objects:

| Frontend field | `propertyID` | Value type |
| --- | --- | --- |
| `bucket` | `app:bucket` | `"inbox"` \| `"next"` \| `"waiting"` \| `"calendar"` \| `"someday"` |
| `rawCapture` | `app:rawCapture` | string |
| `isFocused` | `app:isFocused` | boolean |
| `confidence` | `app:confidence` | `"low"` \| `"medium"` \| `"high"` |
| `needsEnrichment` | `app:needsEnrichment` | boolean |
| `energyLevel` | `app:energyLevel` | `"low"` \| `"medium"` \| `"high"` |
| `sequenceOrder` | `app:sequenceOrder` | number |
| `delegatedTo` | `app:delegatedTo` | string |
| `contexts` | `app:contexts` | CanonicalId[] |
| `captureSource` | `app:captureSource` | structured object |
| `origin` | `app:origin` | `"triaged"` \| `"captured"` \| `"file"` |
| `dueDate` | `app:dueDate` | ISO date string |
| `startDate` | `app:startDate` | ISO date string |
| `scheduledTime` | `app:scheduledTime` | HH:MM string |
| `desiredOutcome` | `app:desiredOutcome` | string |
| `status` (project) | `app:projectStatus` | `"active"` \| `"completed"` \| `"on-hold"` \| `"archived"` |
| `reviewDate` | `app:reviewDate` | ISO date string |
| `ports` | `app:ports` | Port[] |
| `typedReferences` | `app:typedReferences` | TypedReference[] |
| `archivedAt` | `app:archivedAt` | ISO timestamp |
| `provenanceHistory` | `app:provenanceHistory` | ProvenanceEntry[] |
| (server-managed) | `app:nameProvenance` | `{ setBy: "user" \| "ai" \| "system", setAt: string, source: string }` |

---

## Entity Hierarchy

### Base Entity (`BaseEntity`)

All entities share these fields:

| Field | Type | Origin |
| --- | --- | --- |
| `id` | `CanonicalId` | FRBR/ELI canonical IDs |
| `name` | `string?` | schema.org `name` — optional for capture-first entities |
| `description` | `string?` | schema.org `description` |
| `tags` | `string[]` | schema.org `keywords` |
| `references` | `TypedReference[]` | LexCEL typed renvoi |
| `captureSource` | `CaptureSource` | LexCEL evidence anchors |
| `provenance` | `Provenance` | LexCEL append-only provenance |
| `ports` | `Port[]` | LexCEL ports |
| `needsEnrichment` | `boolean` | FRBR evidence-first |
| `confidence` | `ConfidenceLevel` | FRBR evidence-first |

### Entity Types

| `@type` | TypeScript type | Bucket(s) | Key additional fields |
| --- | --- | --- | --- |
| `Thing` | `Thing` | `inbox` (or any, if not yet triaged) | `rawCapture` |
| `Action` | `Thing` | `next` / `waiting` / `calendar` / `someday` | `contexts`, `isFocused`, `delegatedTo`, `recurrence`, `sequenceOrder` |
| `Project` | `Project` | `project` | `desiredOutcome`, `status`, `actionIds` |
| `CreativeWork` | `ReferenceMaterial` | `reference` (or `inbox` before triage) | `url`, `encodingFormat` |
| `Event` | `CalendarEntry` | `calendar` | `date`, `time`, `duration`, `isAllDay` |

Note: The TypeScript types are frontend ergonomic wrappers. The `@type` is what appears
in JSON-LD and determines schema.org compatibility.

---

## JSON-LD Examples

### Raw text capture — `Thing` in inbox

The minimum: user typed a string. `@type` is `Thing` because we don't know what it is yet.
Note: `name` is **not set** — the raw input lives in `app:rawCapture`.

```json
{
  "@id": "urn:app:inbox:def-456",
  "@type": "Thing",
  "_schemaVersion": 2,
  "dateCreated": "2026-02-07T08:00:00Z",
  "dateModified": "2026-02-07T08:00:00Z",
  "additionalProperty": [
    { "@type": "PropertyValue", "propertyID": "app:bucket", "value": "inbox" },
    { "@type": "PropertyValue", "propertyID": "app:rawCapture", "value": "Fahrkosten Müller prüfen" },
    { "@type": "PropertyValue", "propertyID": "app:needsEnrichment", "value": true },
    { "@type": "PropertyValue", "propertyID": "app:confidence", "value": "low" },
    { "@type": "PropertyValue", "propertyID": "app:captureSource", "value": { "kind": "thought" } }
  ]
}
```

### URL capture — `CreativeWork` in inbox

User pasted a URL. The system detects it's a reference and sets `@type: "CreativeWork"`
immediately, but it's still in the inbox bucket until the user triages it.

```json
{
  "@id": "urn:app:inbox:url-789",
  "@type": "CreativeWork",
  "_schemaVersion": 2,
  "name": "SGB III § 159 - Ruhen bei Sperrzeit",
  "url": "https://www.gesetze-im-internet.de/sgb_3/__159.html",
  "dateCreated": "2026-02-07T08:05:00Z",
  "dateModified": "2026-02-07T08:05:00Z",
  "additionalProperty": [
    { "@type": "PropertyValue", "propertyID": "app:bucket", "value": "inbox" },
    { "@type": "PropertyValue", "propertyID": "app:needsEnrichment", "value": true },
    { "@type": "PropertyValue", "propertyID": "app:confidence", "value": "medium" },
    { "@type": "PropertyValue", "propertyID": "app:captureSource", "value": { "kind": "thought" } }
  ]
}
```

### Action (`Action`)

`name` is omitted — the raw capture text lives in `app:rawCapture`. If the user later
renames this action, `name` would appear as a top-level property.

```json
{
  "@id": "urn:app:action:abc-123",
  "@type": "Action",
  "_schemaVersion": 2,
  "description": "Reisekostenabrechnung vom 15.11.2025 nachverfolgen",
  "dateCreated": "2026-02-01T10:30:00Z",
  "dateModified": "2026-02-05T14:22:00Z",
  "startTime": "2026-02-10",
  "isPartOf": { "@id": "urn:app:project:xyz-789" },
  "keywords": ["dringend"],
  "additionalProperty": [
    { "@type": "PropertyValue", "propertyID": "app:bucket", "value": "next" },
    { "@type": "PropertyValue", "propertyID": "app:rawCapture", "value": "Frau Müller wegen Fahrkosten anrufen" },
    { "@type": "PropertyValue", "propertyID": "app:isFocused", "value": true },
    { "@type": "PropertyValue", "propertyID": "app:energyLevel", "value": "low" },
    { "@type": "PropertyValue", "propertyID": "app:confidence", "value": "high" },
    { "@type": "PropertyValue", "propertyID": "app:needsEnrichment", "value": false },
    { "@type": "PropertyValue", "propertyID": "app:contexts", "value": ["urn:app:context:phone"] }
  ]
}
```

### Project (`Project`)

```json
{
  "@id": "urn:app:project:xyz-789",
  "@type": "Project",
  "_schemaVersion": 2,
  "name": "Reisekostenabrechnungen Q1 bearbeiten",
  "description": "Alle Q1-Fahrkostenanträge geprüft und abgelegt",
  "dateCreated": "2026-01-15T09:00:00Z",
  "dateModified": "2026-02-05T14:22:00Z",
  "hasPart": [{ "@id": "urn:app:action:abc-123" }],
  "additionalProperty": [
    { "@type": "PropertyValue", "propertyID": "app:bucket", "value": "project" },
    { "@type": "PropertyValue", "propertyID": "app:desiredOutcome", "value": "Alle Q1-Anträge abgerechnet" },
    { "@type": "PropertyValue", "propertyID": "app:projectStatus", "value": "active" },
    { "@type": "PropertyValue", "propertyID": "app:isFocused", "value": false }
  ]
}
```

### Reference material (`CreativeWork`)

```json
{
  "@id": "urn:app:reference:b8c9d0e1",
  "@type": "CreativeWork",
  "_schemaVersion": 2,
  "name": "SGB III § 159 - Ruhen bei Sperrzeit",
  "url": "https://www.gesetze-im-internet.de/sgb_3/__159.html",
  "encodingFormat": "text/html",
  "dateCreated": "2026-02-03T11:00:00Z",
  "dateModified": "2026-02-03T11:00:00Z",
  "additionalProperty": [
    { "@type": "PropertyValue", "propertyID": "app:bucket", "value": "reference" },
    { "@type": "PropertyValue", "propertyID": "app:origin", "value": "captured" }
  ]
}
```

---

## Typed References (LexCEL Renvoi)

| Type | Meaning |
| --- | --- |
| `blocks` | This item blocks another from starting |
| `depends_on` | Cannot start until dependency completes |
| `delegates_to` | Assigned to someone else |
| `refers_to` | General cross-reference |
| `context_of` | Context tagging |
| `part_of` | Sub-action of a project |
| `follows` | Sequential ordering within a project |
| `waiting_on` | External dependency |

---

## Ports (LexCEL)

| Port | Kind | Purpose |
| --- | --- | --- |
| `DefinitionPort` | `definition` | What does "done" mean? (`doneCriteria`) |
| `PredicatePort` | `predicate` | Conditions to start (`conditions[]`) |
| `ComputationPort` | `computation` | Effort estimates (`timeEstimate`, `energyLevel`) |
| `ProcedurePort` | `procedure` | Checklist steps (`steps[]`) |

---

## Enrichable Interface (FRBR)

| Field | Type | Description |
| --- | --- | --- |
| `needsEnrichment` | `boolean` | Flagged for review/clarification |
| `confidence` | `high` / `medium` / `low` | How well-defined the item is |

**Workflow**: Items enter as `confidence: "low"`, `needsEnrichment: true`.
Clarification moves them to `confidence: "high"`, `needsEnrichment: false`.

---

## Name vs rawCapture Semantics

`rawCapture` holds the user's original input text. `name` is an optional deliberate label,
only set when the user (or AI, with provenance) explicitly renames an item.

### Per-entity rules

| Entity type | `name` | `rawCapture` |
| --- | --- | --- |
| Thing (inbox) | optional — unset at capture | **required** |
| Action | optional — unset at capture | **required** |
| Project | **required** | n/a |
| ReferenceMaterial | **required** | n/a |
| Context | **required** | n/a |

### Display logic

```typescript
// frontend/src/model/types.ts
getDisplayName(item) → item.name ?? item.rawCapture ?? "Untitled"
```

### Lifecycle

1. **Capture**: user types "buy bananas" → `rawCapture = "buy bananas"`, `name` is unset
2. **Triage**: inbox → action — `rawCapture` preserved, `name` stays unset
3. **Rename**: user explicitly sets title → `name = "Weekly Groceries"`, `rawCapture` preserved
4. **Display**: `name` if set, otherwise `rawCapture`, otherwise `"Untitled"`

### JSON-LD serialization

- `name` is **omitted** from JSON-LD when unset (not set to `null`)
- `rawCapture` lives in `additionalProperty` as `app:rawCapture`
- On read (`fromJsonLd`): `null`, missing, `""`, and whitespace-only `name` all normalize to `undefined`

### Factory enforcement

`createThing()` requires at least one of `{name, rawCapture}`. Projects, references, and contexts require `name`.

---

## Provenance (No-Delete)

Every state change is recorded in `provenance.history`:

```typescript
interface ProvenanceEntry {
  timestamp: string; // ISO 8601
  action: ProvenanceAction;
  from?: string; // Previous state
  to?: string; // New state
  note?: string;
}
```

Actions: `created`, `clarified`, `moved`, `updated`, `archived`,
`enriched`, `completed`, `focused`, `unfocused`, `renamed`.

**No deletion** — only archiving via `provenance.archivedAt`.

---

## JSON Schema Contract

The machine-readable contract for JSON-LD payloads lives in `schema/*.schema.json` at the
monorepo root. These files are **generated from the Pydantic models** in `backend/app/models.py`
and serve as the cross-team agreement between frontend and backend.

**Generate schemas**: `cd backend && uv run python scripts/export_jsonld_schemas.py`

**Generate TypeScript types**: `cd frontend && npm run generate:schema-types`

Generated types land in `frontend/src/generated/schema/` and can be used for compile-time
validation. The serializer roundtrip tests in `thing-serializer.test.ts` verify that the
frontend's serialization stays consistent with these schemas.

| Schema file | Pydantic model | Purpose |
| --- | --- | --- |
| `inbox-thing.schema.json` | `InboxThingJsonLd` | Inbox capture payload |
| `action-thing.schema.json` | `ActionThingJsonLd` | Action payload |
| `project-thing.schema.json` | `ProjectThingJsonLd` | Project payload |
| `reference-thing.schema.json` | `ReferenceThingJsonLd` | Reference payload |
| `thing-patch.schema.json` | `ThingPatchModel` | PATCH payload |
| `property-value.schema.json` | `PropertyValueModel` | PropertyValue shape |

See also: [Backend API Requests](?path=/docs/engineering-backend-api-requests-import-ux--docs) for endpoint documentation.

---

## Schema.org Conformance Notes

The app uses schema.org as its primary vocabulary but **intentionally extends** several
property domains beyond their strict schema.org definitions. These deviations are documented
here so consumers of the JSON-LD data understand what is standard and what is app-specific.

### Correct schema.org usage

| Property | schema.org type | Notes |
| --- | --- | --- |
| `name`, `description`, `url` | Thing | Available on all entities |
| `startTime`, `endTime` | Action | Correct temporal properties for Action |
| `encodingFormat` | CreativeWork | MIME type for reference material |
| `PropertyValue` (`propertyID`, `value`) | PropertyValue | Standard extension point |

### Intentional extensions beyond schema.org domains

| Property | Standard domain(s) | Our usage | Rationale |
| --- | --- | --- | --- |
| `additionalProperty` | Product, Place, Offer | All entity types | Universal extension mechanism for `app:*` properties. Schema.org validators are lenient about domain. |
| `keywords` | CreativeWork, Event, Organization | Thing, Action | Tags apply to all entities, not just creative works. Widely used outside strict domain in practice. |
| `dateCreated`, `dateModified` | CreativeWork, DataFeedItem | All entity types | Timestamps are universal. These are the most natural schema.org properties for creation/modification tracking. |
| `isPartOf`, `hasPart` | CreativeWork | Action → Project, Project → Actions | Models project membership. `isPartOf` links an Action to its parent Project; `hasPart` lists a Project's child Actions. |
| `endTime` | Action | Project | Completion timestamp reused for Project. Schema.org `Project` inherits from Organization which has no completion property. |

### Project type and Organization hierarchy

`schema:Project` is a **pending** schema.org type that inherits from `Organization`, not
CreativeWork. This aligns with the app's backend architecture:

- Every user gets a default **Organization** on registration (`"{username}'s Workspace"`)
- All things (including projects) are scoped to an Organization via `org_id`
- Projects live within the user's Organization — the database enforces this relationship
- Users can belong to multiple Organizations (multi-tenancy ready)

The JSON-LD `@type: "Project"` is an intentional choice despite its pending status because
it directly expresses the domain concept. The Organization relationship is enforced at the
API/database layer (not in JSON-LD) via `org_id` scoping.

---

## Type Guards

```typescript
isInboxItem(item); // item.bucket === "inbox"
isAction(item); // bucket in [next, waiting, calendar, someday]
isProject(item); // item.bucket === "project"
isReferenceMaterial(item); // item.bucket === "reference"
```

---

## Test Factories

**File**: `frontend/src/model/factories.ts`

```typescript
// Capture-first entities — rawCapture is primary, name is optional
createThing({ rawCapture: "Anruf bei Frau Müller", bucket: "inbox" });
createThing({ rawCapture: "Deploy", bucket: "next", isFocused: true });
createThing({ name: "Weekly Groceries", rawCapture: "buy bananas", bucket: "next" });

// Non-capture entities — name is required
createProject({ name: "Relaunch", desiredOutcome: "Site live" });
createReferenceMaterial({ name: "SGB III § 159" });
createContext({ name: "@computer" });
createTypedReference({ type: "blocks", targetId });
definitionPort("Wireframes approved");
procedurePort([{ text: "Header" }, { text: "Footer" }]);
```
