import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Testing" />

# Testing Strategy

This document is the testing reference for Senticor Project. It covers test layers, isolation
architecture, patterns, and conventions. For the technology overview see
[Architecture](?path=/docs/engineering-architecture--docs).

---

## Test Layers

| Layer           | Location                     | Tools                                 | External Services                 | Purpose                            |
| --------------- | ---------------------------- | ------------------------------------- | --------------------------------- | ---------------------------------- |
| **Unit**        | `src/**/*.test.ts(x)`        | Vitest (jsdom)                        | None                              | Pure logic, hooks, utilities       |
| **Storybook**   | `src/**/*.stories.tsx`       | Vitest (browser/Playwright), axe-core | MSW (mocked)                      | Interactive UI + accessibility     |
| **Integration** | `e2e/tests/*-mocked.spec.ts` | Playwright                            | Real backend + DB, **mocked** LLM | API contracts, tool execution flow |
| **E2E**         | `e2e/tests/*.spec.ts`        | Playwright                            | **All real** (backend, DB, LLM)   | Full user journeys, no mocking     |

### Layer Rules

1. **Unit tests** — No network calls. Mock external dependencies with `vi.mock()`. Test pure
   functions, hooks, and component rendering in isolation.
2. **Storybook tests** — Use MSW for API mocking. Test user interactions via `play()` functions.
   Every story automatically runs axe-core accessibility audits.
3. **Integration tests** — Real backend + PostgreSQL + agents service, but LLM inference is
   **mocked** via Playwright `page.route()`. Tests are deterministic and fast. Use the
   `*-mocked.spec.ts` naming convention to distinguish from E2E tests.
4. **E2E tests** — Complete real stack including LLM via OpenRouter. No mocking at all.
   Assertions are structural (not exact text) because LLM output is non-deterministic.
   Gated on `OPENROUTER_API_KEY` — auto-skip when no API key.

### UI Interaction Contracts

Keep these interaction behaviors explicitly covered to prevent regressions:

1. **Hamburger menu viewport clamping** — menu never overflows screen bounds.
   Covered by Storybook interaction in `src/components/shell/AppMenu.stories.tsx`.
2. **Chat minimize semantics** — open-state controls use "minimize", not "close".
   Covered by Storybook and unit tests in
   `src/components/chat/CopilotChatPanel.stories.tsx` and
   `src/components/chat/CopilotChatPanel.test.tsx`.
3. **Floating chat launcher visibility** — launcher is hidden while chat panel is open.
   Covered by unit test in `src/App.test.tsx`.

---

## Quick Start

```bash
# Unit tests (never use watch mode in CI)
cd frontend && CI=1 npx vitest run --project=unit

# Storybook tests (browser mode)
cd frontend && STORYBOOK_TESTS=1 CI=1 npx vitest run --project=storybook

# Type checking (MUST use -b for Senticor Project references)
cd frontend && npx tsc -b --noEmit

# Integration + E2E tests (spins up backend + frontend + test database)
cd frontend && npm run e2e

# E2E tests (against already-running services, excludes LLM tests)
cd frontend && npm run test:e2e

# E2E tests with real LLM (requires OPENROUTER_API_KEY + running services)
cd frontend && npm run test:e2e:llm

# Coverage reports
cd frontend && npm run test:coverage:unit        # coverage/unit/
cd frontend && npm run test:coverage:storybook   # coverage/storybook/
```

---

## Test Isolation Architecture

Tests are completely isolated from development data. There is **zero risk** of test/dev data
leakage.

### Frontend Isolation

| Aspect              | Mechanism                         | Location                     |
| ------------------- | --------------------------------- | ---------------------------- |
| **API calls**       | MSW (Mock Service Worker)         | `src/test/msw/handlers.ts`   |
| **In-memory store** | `Map`-based item store            | `src/test/msw/fixtures.ts`   |
| **Handler reset**   | `server.resetHandlers()` per test | `.storybook/vitest.setup.ts` |
| **DOM cleanup**     | `cleanup()` after each test       | `src/test/setup.ts`          |
| **Query client**    | Fresh `QueryClient` per story     | `.storybook/preview.tsx`     |

MSW intercepts all HTTP requests at the network level. No real backend communication occurs
during unit or storybook tests.

### Backend Isolation

| Aspect             | Mechanism                                             |
| ------------------ | ----------------------------------------------------- |
| **Database**       | PostgreSQL with per-session schema (`test_{uuid}`)    |
| **Schema setup**   | `db/schema.sql` applied once per session              |
| **File storage**   | `tmp_path_factory` (session-scoped temp directory)    |
| **Authentication** | Real register/login via `auth_client` fixture         |
| **Worker**         | Manual `process_batch()` calls (no background thread) |

Each test session creates a unique PostgreSQL schema. Tests share that schema but each gets
a fresh `TestClient` (function scope). The `auth_client` fixture registers and logs in a
unique user per test.

### E2E Isolation

E2E tests run against a dedicated service stack started by `scripts/e2e-stack.sh`. The script
creates an isolated PostgreSQL database (`project_e2e`), starts the backend on port 8001,
and the frontend on port 5174. Environment overrides live in `.env.e2e` (separate session
cookies, file storage path).

A custom Playwright fixture provides `authenticatedPage` (auto-registers a unique user via
local JWT auth) and `apiSeed` (programmatic data setup via API).

---

## Backend Testing

### Fixtures

| Fixture             | Scope    | Provides                                                 |
| ------------------- | -------- | -------------------------------------------------------- |
| `test_database_url` | session  | Isolated PostgreSQL schema with env vars set             |
| `app`               | session  | FastAPI app with schema applied                          |
| `client`            | function | `TestClient` (no auth)                                   |
| `auth_client`       | function | `TestClient` with registered + logged-in user            |
| `api_base_url`      | session  | Live uvicorn server URL for Playwright integration tests |

### Outbox Event Testing

The outbox worker does **not** run in the background during tests. Tests that need worker
processing must call `process_batch()` explicitly.

**Pattern:**

1. Call the API endpoint (creates outbox event)
2. Clean up unrelated events: `DELETE FROM outbox_events WHERE payload->>'job_id' IS DISTINCT FROM %s`
3. Call `process_batch(limit=N)` to process the target event
4. Poll job status until complete — don't assert on `process_batch()` return value

**Gotcha:** All tests share a session-scoped database. `process_batch()` processes **all**
unprocessed events, not just the current test's. Always clean up unrelated events before
calling it, and poll job status with retries rather than asserting exact batch counts.

```python
# Clean up events from other tests
with db_conn() as conn:
    with conn.cursor() as cur:
        cur.execute(
            "DELETE FROM outbox_events WHERE payload->>'job_id' IS DISTINCT FROM %s",
            (job_id,),
        )
    conn.commit()

# Process — may be 0 if already consumed
process_batch(limit=10)

# Poll with retry
for _ in range(20):
    job = auth_client.get(f"/imports/jobs/{job_id}")
    if job.json()["status"] in ("completed", "failed"):
        break
    process_batch(limit=10)
    time.sleep(0.25)
```

### Backend Quick Start

```bash
cd backend
uv run python -m pytest                    # Full suite
uv run python -m pytest tests/test_foo.py  # Single file
uv run python -m pytest -x -q             # Stop on first failure, quiet
uv run ruff check .                        # Lint
uv run mypy app/                           # Types
```

---

## MSW Patterns

### Handler URL Convention

All fetch URLs are absolute (`VITE_API_BASE_URL=http://localhost:8000`). MSW handlers **must**
use a wildcard prefix to match any origin:

```typescript
// Correct — matches any origin
http.get("*/items/sync", () => { ... })

// Wrong — only matches vitest page origin
http.get("/items/sync", () => { ... })
```

### Per-Story Handler Overrides

Override default handlers for a specific story via `parameters.msw.handlers`:

```typescript
export const EmptyState: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get("*/items/sync", () =>
          HttpResponse.json({
            items: [],
            deletedIds: [],
            serverTime: new Date().toISOString(),
          }),
        ),
      ],
    },
  },
};
```

The preview loader applies overrides via `worker.use()`. Cleaned up by `afterEach(worker.resetHandlers)`.

### SSE / Streaming Handlers

For server-sent events or streaming responses:

```typescript
http.get("*/stream", () => {
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(encoder.encode('data: {"event":"delta"}\n\n'));
      controller.close();
    },
  });
  return new HttpResponse(stream, {
    headers: { "Content-Type": "text/event-stream" },
  });
});
```

### MSW Double-Start Prevention

When `preview.tsx` is imported by `vitest.setup.ts`, module-level side effects run. Guard
`worker.start()` with the vitest check to avoid double-start:

```typescript
if (!import.meta.env.VITEST) {
  worker.start({ onUnhandledRequest: "bypass" });
}
```

---

## Test Data Factories

### `createItemRecord(overrides)`

The primary factory in `src/test/msw/fixtures.ts`. Generates a complete `ItemRecord` with
unique IDs, canonical IDs, timestamps, and proper JSON-LD structure.

```typescript
const item = createItemRecord({ bucket: "next", name: "Buy groceries" });
const project = createItemRecord({
  bucket: "project",
  type: "Project",
  name: "Kitchen reno",
});
const focused = createItemRecord({ bucket: "next", isFocused: true });
```

### Preset Seeders

```typescript
seedInboxItems(5); // 5 unprocessed inbox items
seedMixedBuckets(); // 8 items across all buckets
```

### `buildSyncResponse()`

Wraps the current store state in a `SyncResponse` envelope for the `/items/sync` handler.

---

## Accessibility Testing

### Storybook (Automatic)

Every story runs axe-core audits automatically via `@storybook/addon-a11y`. Violations fail
the test (`a11y.test: "error"` in preview config).

**Disabled rules:**

- `color-contrast` — axe-core cannot evaluate CSS `oklch()` or custom properties. Palette
  manually verified for WCAG AA (≥4.5:1 contrast ratio).

### Unit Tests (vitest-axe)

For components not covered by stories, or when you want axe checks closer to the component
logic, use `vitest-axe` directly in unit tests. The `toHaveNoViolations` matcher is globally
available via `src/test/setup.ts`.

```typescript
import { axe } from "vitest-axe";

test("has no accessibility violations", async () => {
  const { container } = render(<MyComponent />);
  expect(await axe(container)).toHaveNoViolations();
});
```

### Query Priority

Follow Testing Library's
[query priority](https://testing-library.com/docs/queries/about#priority):

1. `getByRole` — accessible name, role
2. `getByLabelText` — form controls
3. `getByPlaceholderText` — fallback for unlabeled inputs
4. `getByText` — visible text content
5. `getByTestId` — last resort only

Page objects in E2E tests also use accessible queries (`getByRole`, `getByLabel`).

---

## Integration & E2E Patterns

### Integration vs E2E Naming

Tests using Playwright share the `e2e/tests/` directory but are split into two layers:

- **`*-mocked.spec.ts`** = **Integration** — uses `page.route()` to mock external services (e.g. LLM inference). Fast, deterministic, runs in CI without API keys.
- **`*.spec.ts`** = **E2E** — no mocking at all. Exercises the complete stack including real LLM calls. Gated on `OPENROUTER_API_KEY`, excluded from default test runs.

The `chromium` Playwright Senticor Project runs all tests **except** `*-llm.spec.ts`. The `llm` Senticor Project runs only LLM E2E tests.

### Page Objects

Each screen has a page object in `e2e/pages/`:

```typescript
const workspace = new WorkspacePage(page);
await workspace.navigateTo("next");
await workspace.captureInboxItem("Buy milk");
```

Page objects encapsulate locators and actions. All locators use accessible queries.

### API Seeding

Use the `apiSeed` fixture for programmatic data creation instead of UI-driven setup:

```typescript
test("filters by context", async ({ authenticatedPage, apiSeed }) => {
  await apiSeed.createAction("Call dentist", "next", { contexts: ["@phone"] });
  // Test filtering...
});
```

This is faster and more reliable than clicking through the UI to create test data.

### Authenticated Fixture

The `authenticatedPage` fixture auto-registers a unique user, logs in, and asserts the
workspace has loaded. Each test gets a fresh user with no data.

---

## LLM & AI Testing

Copilot chat scenarios are tested at two layers: **integration** (mocked LLM, deterministic)
and **E2E** (real LLM via OpenRouter, structural assertions). Both layers share a
**golden dataset** (`e2e/fixtures/golden-prompts.ts`) as their single source of truth.

For full documentation of the agent architecture, tool schemas, golden dataset format,
LLM cache, trace files, and evaluation workflow, see the dedicated
[LLM Evaluation](?path=/docs/engineering-llm-evaluation--docs) page.

**Quick reference:**

- Integration tests: `npm run test:e2e` (always runs in CI)
- E2E tests: `npm run test:e2e:llm` (requires `OPENROUTER_API_KEY`)

---

## Component Test Patterns

### Rendering with Providers

Unit tests that need providers should wrap manually:

```typescript
import { QueryClientProvider, QueryClient } from "@tanstack/react-query";

function renderWithClient(ui: React.ReactElement) {
  const client = new QueryClient({ defaultOptions: { queries: { retry: false } } });
  return render(<QueryClientProvider client={client}>{ui}</QueryClientProvider>);
}
```

### User Events

Always use the modern `userEvent.setup()` API:

```typescript
import userEvent from "@testing-library/user-event";

test("submits form", async () => {
  const user = userEvent.setup();
  render(<MyForm />);
  await user.type(screen.getByLabelText("Name"), "Test");
  await user.click(screen.getByRole("button", { name: /submit/i }));
  expect(await screen.findByText("Saved")).toBeInTheDocument();
});
```

### TanStack Query Hook Testing

Mutation hooks follow the **snapshot → optimistic update → rollback** pattern. Tests use
`renderHook` with a `QueryClientProvider` wrapper:

```typescript
function createWrapper(initialData?: ItemRecord[]) {
  const qc = new QueryClient({
    defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
  });
  if (initialData) qc.setQueryData(ACTIVE_KEY, initialData);
  return ({ children }) =>
    createElement(QueryClientProvider, { client: qc }, children);
}
```

**Testing flow:**

1. Seed the query cache with initial data via `createWrapper([...records])`
2. Call `mutate()` / `mutateAsync()` in an `act()` block
3. Assert API mock was called with expected args
4. For optimistic updates: observe cache state before API resolves (use a pending Promise)
5. For rollback: reject the mock and verify cache is restored
6. For `onSettled`: verify `invalidateQueries` was awaited (prevents stale-cache races)

**Polling tests** use `vi.useFakeTimers()` + `vi.advanceTimersByTimeAsync()` to verify
`refetchInterval` behavior without real delays.

### Storybook Play Functions

In play functions, `userEvent` **must** come from the play function context (instrumented for
the Interactions panel). Other utilities are imported normally:

```typescript
import { expect, waitFor, within } from "storybook/test";

export const Interactive: Story = {
  play: async ({ canvas, userEvent }) => {
    // userEvent from context — NOT imported
    await userEvent.click(canvas.getByRole("button", { name: /add/i }));
    await expect(canvas.getByText("Added")).toBeVisible();
  },
};
```

---

## Flaky Test Prevention

Flaky tests undermine confidence. Follow these rules:

1. **Never use fixed delays** — Use `waitFor` or `findBy*` queries instead of `setTimeout`
   or arbitrary waits.
2. **Clean up after each test** — `cleanup()` for DOM, `server.resetHandlers()` for MSW,
   store resets for state.
3. **Await all async operations** — Missing `await` is the most common cause of flaky tests.
   This includes `invalidateQueries()` in mutation `onSettled` callbacks — always `async/await`.
4. **Use deterministic data** — Factories with predictable outputs, not random data.
5. **Framer Motion caveat** — `AnimatePresence` exit animations don't instantly unmount in
   jsdom. Use `waitFor` to assert removal.
6. **act() warnings fail tests** — The unit test setup intercepts `console.error` and throws
   on React `act()` warnings. This catches state-update-outside-act bugs early.

### Flaky Test Tracking

When a test is identified as flaky, create a **GitHub issue** with the label `flaky-test`.
Include the test name, file path, and observed failure pattern. Fix flaky tests with high
priority — they erode team confidence in the suite.

---

## E2E Gotchas

### Inbox Triage Order

The inbox sorts items by `provenance.createdAt` **descending** (newest first). Which item gets
triaged first depends on how items were created:

| Scenario                     | First triaged item      | Why                                                      |
| ---------------------------- | ----------------------- | -------------------------------------------------------- |
| **UI capture** (no reload)   | First captured (oldest) | Auto-expand fires when first item arrives; scopilots set |
| **API seed + `page.reload`** | Newest (last created)   | Fresh state — auto-expand picks `sorted[0]`              |

After the first triage, **auto-advance always picks the newest remaining** item (`sorted[0]`).

When writing triage tests with `apiSeed.createInboxItems(...)`, create items in **reverse
order** so the test reads naturally (newest item = first triaged = first in the array):

```typescript
// Items created oldest→newest. Inbox sorts newest first.
// "Waiting item" (newest) auto-expands → triaged first.
await apiSeed.createInboxItems([
  "Reference item", // oldest → triaged last
  "Calendar item",
  "Waiting item", // newest → triaged first
]);
```

### Archive vs. Empty State

Archiving an inbox item moves it to the **Done** section (completed items in `ItemList`).
When the Done section is visible, `emptyMessage` ("Inbox is empty") does **not** render
because `hasSecondaryItems` is true. Assert the item is gone instead:

```typescript
// Wrong — Done section prevents empty message
await expect(page.getByText("Inbox is empty")).toBeVisible();

// Correct — verify the item disappeared
await expect(page.getByText("Disposable thought")).not.toBeVisible();
await expect(page.getByText("0 items to process")).toBeVisible();
```

### Playwright Strict Mode

`page.getByRole("alert")` fails with a strict mode violation when multiple alerts exist.
Always filter to match a specific element:

```typescript
// Wrong — matches all alerts
await expect(page.getByRole("alert")).not.toBeVisible();

// Correct — filter to the specific alert
await expect(
  page.getByRole("alert").filter({ hasText: "already imported" }),
).not.toBeVisible();
```

### E2E Stack: Outbox Worker

`scripts/e2e-stack.sh` starts the outbox worker (`uv run python -m app.worker --loop`).
Without it, import jobs scopilot in "queued" status forever. If adding new async workflows that
depend on outbox processing, verify the worker is running in the E2E stack.

### CI-Only Skip for Expensive Tests

For hardware-dependent or large-file tests that should not block CI:

```typescript
test.skip(
  !!process.env.CI || !fixtureExists,
  "Large-file import test — local only",
);
```

### Optimistic Update Races

Mutation `onSettled` callbacks must `await` the `invalidateQueries()` call. Without `await`,
the query refetch races with the next user action. This manifests as items "flickering back"
in E2E tests after triage or archive — the stale server response briefly overwrites the
optimistic update.

---

## Debugging Tests

### Verbose Output

```bash
# Verbose reporter
cd frontend && CI=1 npx vitest run --project=unit --reporter=verbose

# Single file
cd frontend && CI=1 npx vitest run --project=unit src/components/ui/Icon.test.tsx
```

### MSW Debugging

Temporarily switch to strict mode to catch unhandled requests:

```typescript
server.listen({ onUnhandledRequest: "error" });
```

### E2E Debugging

```bash
# Run headed (visible browser)
cd frontend && npm run test:e2e:headed

# Traces on failure (configured: on-first-retry)
cd frontend && npx playwright show-trace test-results/*/trace.zip
```

---

## Conventions

| Convention         | Rule                                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------------------------- |
| **File naming**    | `.test.tsx` for unit, `.stories.tsx` for storybook, `*-mocked.spec.ts` for Integration, `.spec.ts` for E2E |
| **Test runner**    | Always `CI=1 npx vitest run` — never watch mode in CI                                                      |
| **Type checking**  | `npx tsc -b --noEmit` — must use `-b` for Senticor Project references                                      |
| **Cleanup**        | Explicit `cleanup()` in setup (no `globals: true`)                                                         |
| **Mocking**        | MSW for network, `vi.mock()` for modules — prefer MSW when possible                                        |
| **Assertions**     | `@testing-library/jest-dom` + `vitest-axe` matchers                                                        |
| **Coverage**       | v8 provider, thresholds: 80% lines/statements/functions, 70% branches                                      |
| **act() warnings** | Fail tests — enforced in `src/test/setup.ts`                                                               |
