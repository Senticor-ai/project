import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/FRBR Architecture" />

# Evidence-First FRBR Architecture

**Core principle**: Always create complete FRBR hierarchy. Use "unknown" placeholders
when information is not in the source. Let enrichment fill gaps later.

This document describes the FRBR (Functional Requirements for Bibliographic Records)
implementation for the knowledge graph layer, including current status and proposed
improvements.

For how FRBR maps to GTD concepts, see
[Data Model](?path=/docs/engineering-data-model--docs) and
[GTD Methodology](?path=/docs/product-gtd-methodology--docs).
For typed references and ports, see
[LexCEL Architecture](?path=/docs/engineering-lexcel-architecture--docs).

---

## Implementation Status

| Feature                     | Status          | Notes                                                   |
| --------------------------- | --------------- | ------------------------------------------------------- |
| **Complete FRBR Hierarchy** | Implemented     | Work &rarr; Expression &rarr; Manifestation &rarr; Item |
| **Granular Manifestations** | Implemented     | One per section (correct)                               |
| **FRBR Relationships**      | Mostly correct  | Item links need fix (see Known Issues)                  |
| **Three-Phase Processing**  | Not implemented | Still using simple heuristics                           |
| **Unknown Placeholders**    | Not implemented | No `lc:needsEnrichment` pattern                         |
| **Always-Create Pattern**   | Not implemented | Still conditional logic                                 |
| **LLM Metadata Enrichment** | Not implemented | Only heuristic detection                                |

---

## Current Problem

The system creates nodes conditionally and hardcodes information:

- Deutschland node only if German docs exist
- BA node only if BA docs exist
- Hardcoded names, URLs, relationships

This creates inconsistency and makes assumptions.

---

## Implemented: Core FRBR Hierarchy

The system successfully creates a complete FRBR hierarchy for all documents.

**Implementation** (`frbr-builder.mjs`):

| FRBR Level        | Description                             | Example URN                                                                  |
| ----------------- | --------------------------------------- | ---------------------------------------------------------------------------- |
| **Work**          | Abstract legal concept                  | `urn:de:frbr:work:ba:weisung`                                                |
| **Expression**    | Specific version                        | `urn:de:frbr:expression:ba:weisung:current`                                  |
| **Manifestation** | One per section for granular provenance | `urn:de:frbr:manifestation:ba:weisung:202511001:text/markdown:bundesagentur` |
| **Item**          | File instance                           | `urn:de:frbr:item:ba:weisung:weisung-202511001_ba054998`                     |

**Correct Relationships**:

- Expression &rarr; `frbr:realizationOf` &rarr; Work
- Manifestation &rarr; `frbr:embodimentOf` &rarr; Expression
- Integration with LegalRuleML (`lrml:LegalSource` nodes)

---

## Known Issues

### 1. Item Links to Wrong Level

```json
// CURRENT (incorrect):
{ "@type": "frbr:Item", "frbr:exemplarOf": { "@id": "urn:de:frbr:expression:..." } }

// SHOULD BE:
{ "@type": "frbr:Item", "frbr:exemplarOf": { "@id": "urn:de:frbr:manifestation:..." } }
```

Item should exemplify a Manifestation, not an Expression (per FRBR spec).

### 2. LegalSource Links to Expression Instead of Manifestation

```json
// CURRENT:
{ "@type": "lrml:LegalSource", "frbr:embodiment": { "@id": "urn:de:frbr:expression:..." } }

// SHOULD BE:
{ "@type": "lrml:LegalSource", "frbr:embodiment": { "@id": "urn:de:frbr:manifestation:..." } }
```

Each section should link to its specific Manifestation for proper provenance tracking.

### 3. Missing Reverse Link

- Manifestation should link back to Item
- Currently only Item &rarr; Expression exists

---

## Proposed: Three-Phase Processing

### Phase 1: Document Classification (NO LLM)

**Input**: Raw markdown file
**Output**: Document type, detected metadata
**Location**: `structure-parser.mjs`

```javascript
function classifyDocument(filePath, content) {
  return {
    language: detectLanguage(content), // "de" or "unknown"
    documentType: detectDocumentType(content), // "weisung", "ba-document", "statute", "article", "unknown"
    publisher: detectPublisher(filePath), // "bundesagentur", "gesetze-im-internet", "unknown"
    jurisdiction: detectJurisdiction(content), // "de:jurisdiction", "unknown"
    documentId: extractDocumentId(filePath), // From filename
  };
}
```

**Detection logic** (heuristic, no LLM):

- Language: Check for German words, umlauts
- Document type: Filename patterns, content markers
- Publisher: Filename patterns (`weisung-*`, `dok_ba*`, `BJNR*`)
- Jurisdiction: Language + publisher hints

### Phase 2: FRBR Hierarchy Creation (NO LLM)

**Input**: Classified document + sections
**Output**: Complete FRBR hierarchy with placeholders
**Location**: `frbr-builder.mjs`

```javascript
function buildCompleteHierarchy(classification, sections) {
  // ALWAYS create jurisdiction node (even if unknown)
  const jurisdiction = {
    "@id": classification.jurisdiction || "urn:unknown:jurisdiction",
    "@type": "lrml:Jurisdiction",
    "schema:name":
      classification.jurisdiction === "de:jurisdiction"
        ? "Germany"
        : "Unknown Jurisdiction",
    "lc:needsEnrichment": classification.jurisdiction === "unknown",
  };

  // ALWAYS create organization node (even if unknown)
  const organization = {
    "@id": classification.publisher
      ? `urn:de:org:${classification.publisher}`
      : "urn:unknown:organization",
    "@type": "schema:Organization",
    "schema:name":
      getOrganizationName(classification.publisher) || "Unknown Organization",
    "schema:parentOrganization": { "@id": jurisdiction["@id"] },
    "lc:needsEnrichment": !classification.publisher,
  };

  // ALWAYS create Work, Expression, Manifestations, Item
  // ...
  return { jurisdiction, organization, work, expression, manifestations, item };
}
```

### Phase 3: Enrichment (OPTIONAL LLM)

**Input**: Graph with placeholders
**Output**: Enriched graph with unknowns filled
**Location**: `semantic-enricher.mjs` (new capability)

```javascript
async function enrichUnknownNodes(graph) {
  const unknownNodes = graph.nodes.filter((n) => n["lc:needsEnrichment"]);

  for (const node of unknownNodes) {
    if (node["@type"] === "lrml:Jurisdiction") {
      const jurisdiction = await llm.identifyJurisdiction(node.evidence);
      node["schema:name"] = jurisdiction.name;
      node["@id"] = jurisdiction.urn;
      delete node["lc:needsEnrichment"];
    }

    if (node["@type"] === "schema:Organization") {
      const org = await llm.identifyPublisher(node.evidence);
      node["schema:name"] = org.name;
      node["schema:url"] = org.url;
      delete node["lc:needsEnrichment"];
    }
  }

  return graph;
}
```

---

## Benefits

### 1. Consistency

- ALWAYS complete FRBR hierarchy
- No conditional node creation
- Predictable graph structure

### 2. Transparency

- Clear what's detected vs unknown
- `lc:needsEnrichment` flag shows gaps
- No hidden assumptions

### 3. Flexibility

- Works without LLM (structure-only)
- LLM enrichment is optional
- Can enrich later/incrementally

### 4. Evidence-Based

- Text content is the evidence
- FRBR hierarchy organizes evidence
- Metadata derived from evidence

---

## Example: Unknown Document

### Input

```markdown
# Some Document

This is a document about something.
```

### Phase 1: Classification

```javascript
{
  language: "unknown",
  documentType: "article",
  publisher: "unknown",
  jurisdiction: "unknown",
  documentId: "some-document"
}
```

### Phase 2: FRBR Hierarchy

```json
{
  "jurisdiction": {
    "@id": "urn:unknown:jurisdiction",
    "@type": "lrml:Jurisdiction",
    "schema:name": "Unknown Jurisdiction",
    "lc:needsEnrichment": true
  },
  "organization": {
    "@id": "urn:unknown:organization",
    "@type": "schema:Organization",
    "schema:name": "Unknown Organization",
    "lc:needsEnrichment": true
  },
  "work": {
    "@id": "urn:de:frbr:work:some-document",
    "@type": "frbr:Work",
    "schema:publisher": { "@id": "urn:unknown:organization" }
  }
}
```

### Phase 3: Enrichment (Optional)

```json
{
  "jurisdiction": {
    "@id": "urn:de:jurisdiction",
    "@type": "lrml:Jurisdiction",
    "schema:name": "Germany"
  },
  "organization": {
    "@id": "urn:de:org:bundesagentur",
    "@type": "schema:Organization",
    "schema:name": "Bundesagentur f√ºr Arbeit"
  }
}
```

---

## Migration Path

1. **Phase 1**: Add classification function (non-breaking)
2. **Phase 2**: Change conditional to always-create (breaking change)
3. **Phase 3**: Add enrichment capability (optional feature)

---

## Open Questions

1. **Unknown node IDs**: Use `urn:unknown:*` or something else?
2. **Enrichment trigger**: Manual flag or automatic?
3. **Confidence scores**: Add confidence to detected values?
4. **Multiple jurisdictions**: How to handle documents with multiple jurisdictions?
