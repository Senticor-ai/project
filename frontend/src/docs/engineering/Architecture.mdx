import { Meta } from "@storybook/addon-docs/blocks";
import { Mermaid } from "../../components/docs/Mermaid";

<Meta title="Engineering/Architecture" />

# Architecture

This document defines the technology stack, architectural principles, and core patterns
for the system. For the data model that sits on top of this architecture, see
[Data Model](?path=/docs/engineering-ontology--docs).

---

## C4 Architecture Model

Architecture diagrams following the [C4 model](https://c4model.com/) — hierarchical
abstractions from system context down to components.

### Level 1: System Context

Who uses TAY and what external systems does it interact with?

<Mermaid chart={`
C4Context
  title System Context — TerminAndoYo (TAY)

  Person(user, "Bundesbeamter", "Federal clerk managing tasks, documents, and workflows")
  Person(cpa, "CPA / Advisor", "Receives exported document packages")

  System(tay, "TerminAndoYo", "Structured task management with AI-assisted triage, Schema.org data model, append-only audit trail")

  System_Ext(gmail, "Gmail", "IMAP email sync via OAuth 2.0")
  System_Ext(openrouter, "OpenRouter", "LLM access for Tay AI agent")
  System_Ext(grafana, "Grafana LGTM", "Logs, traces, metrics via OpenTelemetry")

  Rel_D(user, tay, "Captures tasks, triages inbox, manages projects", "HTTPS")
  Rel_D(cpa, tay, "Receives exported document packages", "CSV/PDF/ZIP")
  Rel_D(tay, gmail, "Syncs email to inbox", "IMAP + OAuth")
  Rel_D(tay, openrouter, "AI-assisted triage and planning", "HTTPS/REST")
  Rel_D(tay, grafana, "Exports telemetry", "OTLP")

  UpdateLayoutConfig($c4ShapeInRow="2", $c4BoundaryInRow="1")
`} />

### Level 2: Container Diagram

What are the running processes, data stores, and how do they communicate?

<Mermaid chart={`
C4Container
  title Container Diagram — TerminAndoYo

  Person(user, "User", "Federal clerk")

  System_Boundary(tay, "TerminAndoYo") {
    Container(spa, "Frontend SPA", "React 19, Vite, Tailwind v4", "Single-page app with offline-first sync, bucket navigation, inline triage")
    Container(storybook, "Storybook", "Storybook 10, MDX", "Living documentation hub — product specs, design system, component demos, architecture docs")
    Container(api, "Backend API", "Python, FastAPI", "REST API for items, files, imports, email, auth, search, push notifications, chat proxy")
    Container(agents, "Agents Service", "Python, Haystack, FastAPI", "Tay AI copilot — chat completions with tool calling via OpenRouter (port 8002)")
    Container(worker, "Projection Worker", "Python", "Outbox consumer: search indexing, email sync, import jobs")
    Container(pushworker, "Push Worker", "Python", "Web Push notification delivery via VAPID")

    ContainerDb(pg, "PostgreSQL 16", "Relational DB", "Source of truth: items (JSON-LD), files, assertions, outbox events, sessions, email connections")
    ContainerDb(meili, "Meilisearch", "Search engine", "Full-text index for items and file content (optional)")
    ContainerDb(files, "File Storage", "PVC / filesystem", "Uploaded files (SHA256 content-addressed)")
  }

  System_Ext(gmail, "Gmail", "IMAP email provider")
  System_Ext(openrouter, "OpenRouter", "LLM provider")

  Rel(user, spa, "Uses", "HTTPS")
  Rel(user, storybook, "Reads docs", "HTTPS")
  Rel(spa, api, "JSON API calls", "HTTPS /api/*")
  Rel(api, pg, "Reads/writes", "SQL")
  Rel(api, files, "Stores/retrieves files", "filesystem")
  Rel(worker, pg, "Polls outbox_events", "SQL")
  Rel(worker, meili, "Indexes items", "REST")
  Rel(worker, gmail, "IMAP sync", "IMAP + OAuth")
  Rel(pushworker, pg, "Polls push_outbox", "SQL")
  Rel(api, agents, "Proxies chat requests", "HTTP")
  Rel(agents, openrouter, "Chat completions", "HTTPS")

  UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
`} />

### Level 3: Components — Backend API

What modules make up the FastAPI backend?

<Mermaid chart={`
C4Component
  title Component Diagram — Backend API (FastAPI)

  Container_Boundary(api, "Backend API") {
    Component(auth, "Auth Module", "FastAPI Router", "Register, login, logout, session refresh, CSRF tokens. HTTP-only cookie sessions stored in PostgreSQL.")
    Component(items, "Items API", "FastAPI Router", "CRUD for JSON-LD items. Cursor-based sync, idempotent writes, soft-delete archive. Outbox event on every write.")
    Component(filesapi, "Files API", "FastAPI Router", "Chunked upload (initiate → chunks → complete). SHA256 dedup. Content-addressed storage.")
    Component(imports, "Imports API", "FastAPI Router", "Nirvana + Native importers. Inspect preview, async job execution, progress polling.")
    Component(email, "Email Module", "FastAPI Router", "Gmail OAuth flow, connection management, manual sync trigger. Encrypted token storage.")
    Component(search, "Search API", "FastAPI Router", "Proxies full-text queries to Meilisearch. Items + file content indices.")
    Component(push, "Push API", "FastAPI Router", "Web Push subscription management via VAPID keys.")
    Component(chat, "Chat Proxy", "FastAPI Router", "Proxies chat completions to agents service. Auth required. Returns text + optional tool calls.")
    Component(schemas, "Schemas API", "FastAPI Router", "Canonical JSON-LD schema definitions for all entity types.")
    Component(metrics, "Observability", "Middleware", "Prometheus metrics, OpenTelemetry tracing, structured logging with trace correlation.")
  }

  ContainerDb(pg, "PostgreSQL", "", "Items, sessions, outbox, email credentials")
  ContainerDb(meili, "Meilisearch", "", "Full-text search index")
  ContainerDb(storage, "File Storage", "", "Uploaded PDFs, docs")
  System_Ext(gmail, "Gmail", "OAuth + IMAP")
  Container_Ext(agents, "Agents Service", "Haystack + OpenRouter")

  Rel(auth, pg, "Sessions, users")
  Rel(items, pg, "Items, outbox events")
  Rel(filesapi, storage, "Store/retrieve files")
  Rel(filesapi, pg, "File metadata")
  Rel(imports, pg, "Import jobs, items")
  Rel(email, pg, "Connections, tokens")
  Rel(email, gmail, "OAuth + IMAP")
  Rel(search, meili, "Query indices")
  Rel(push, pg, "Subscriptions, outbox")
  Rel(chat, agents, "Proxy chat requests")

  UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
`} />

### Level 3: Components — Projection Worker

What does the outbox worker process?

<Mermaid chart={`
C4Component
  title Component Diagram — Projection Worker

  Container_Boundary(worker, "Projection Worker") {
    Component(poller, "Outbox Poller", "Python", "Polls outbox_events table. Batch processing with configurable interval and batch size.")
    Component(searchidx, "Search Indexer", "Python", "Indexes items and file content in Meilisearch. Extracts text from PDFs via pypdf.")
    Component(importer, "Import Processor", "Python", "Runs Nirvana and Native import jobs. Transform → dedup → batch upsert.")
    Component(emailsync, "Email Sync", "Python", "IMAP sync via Gmail. Fetches new messages, transforms to inbox items.")
    Component(pushemit, "Push Emitter", "Python", "Enqueues Web Push notifications in push_outbox on item events.")
    Component(deadletter, "Dead Letter Handler", "Python", "After max retries, moves failed events to dead letter state for manual review.")
  }

  ContainerDb(pg, "PostgreSQL", "", "Outbox events, items, import jobs")
  ContainerDb(meili, "Meilisearch", "", "Search indices")
  System_Ext(gmail, "Gmail", "IMAP")

  Rel(poller, pg, "Polls + marks processed")
  Rel(searchidx, meili, "Index documents")
  Rel(importer, pg, "Batch upsert items")
  Rel(emailsync, gmail, "IMAP fetch")
  Rel(emailsync, pg, "Create inbox items")
  Rel(deadletter, pg, "Dead letter events")

  UpdateLayoutConfig($c4ShapeInRow="4", $c4BoundaryInRow="1")
`} />

---

## Schema.org as Foundation

**Schema.org is the primary ontology.** Every entity in the system is stored as JSON-LD
using a schema.org `@type`. Custom fields use `additionalProperty` (PropertyValue) rather
than a parallel type system. This applies across all layers:

| Layer        | How schema.org is used                                                          |
| ------------ | ------------------------------------------------------------------------------- |
| **Postgres** | `schema_jsonld` column stores JSON-LD with `@type`, `name`, `description`, etc. |
| **Frontend** | TypeScript types map 1:1 to schema.org properties; serializer handles JSON-LD   |

See [Data Model](?path=/docs/engineering-ontology--docs) for type mappings and
[Schema.org Vocabulary](?path=/docs/engineering-ontology-schema-org-vocabulary--docs)
for the full type catalog.

---

## Design Goals

- **Schema.org-first** — interoperable, self-describing data
- **Deterministic behavior** — reproducible outputs for audit and testing
- **AI as supervised collaborator** — AI proposes, humans decide
- **BDD/TDD-first development** — fixtures over live integrations
- **Append-only auditability** — no destructive updates

---

## Architectural Principles

1. **Schema.org-first** — use schema.org types and properties; only add custom extensions when schema.org genuinely has no equivalent
2. **Append-only by default** — no destructive updates; all changes are assertions
3. **Facts before views** — UI state is derived from immutable facts
4. **Postgres is source of truth** — single source of truth for all data
5. **Projections are rebuildable** — search indices can be regenerated from Postgres
6. **AI parity** — AI and humans write the same assertion model
7. **Deterministic tests** — fixtures over live integrations

---

## Technology Stack

### Frontend

| Technology                | Purpose                     |
| ------------------------- | --------------------------- |
| React + Vite              | UI framework and build      |
| Vitest + Testing Library  | Unit & component tests      |
| Playwright                | E2E / BDD scenarios         |
| OpenTelemetry JS SDK      | Trace propagation           |
| MSW (Mock Service Worker) | API mocking for development |

### Backend

| Technology       | Purpose                              |
| ---------------- | ------------------------------------ |
| Python (FastAPI) | API server                           |
| Haystack         | AI pipelines & agents                |
| OpenRouter       | LLM access                           |
| Local auth       | HTTP-only cookie sessions (Postgres) |

### Storage & Indexes

| Store          | Purpose                                                           |
| -------------- | ----------------------------------------------------------------- |
| **PostgreSQL** | Immutable catalog (Items + Assertions, JSON-LD) — source of truth |
| **Meilisearch**| Full-text search index for items and file content (optional)      |
| **Qdrant**     | Vector store (semantic retrieval)                                 |

### Observability

| Technology    | Purpose                                                    |
| ------------- | ---------------------------------------------------------- |
| OpenTelemetry | Distributed tracing                                        |
| Grafana LGTM  | Loki (logs), Grafana (UI), Tempo (traces), Mimir (metrics) |
| MLflow        | LLM & agent evaluation                                     |

---

## Data Store Model

### Core Invariants

1. **Postgres is source of truth.** All persistent state lives in PostgreSQL.
2. **Stable canonical IDs.** Every item has a single canonical `@id`.
3. **Search is a projection.** Meilisearch indices are derived from Postgres and rebuildable.

### Items (Postgres)

All objects are stored as schema.org Things in JSON-LD form.

```sql
-- Table: items
item_id         UUID PRIMARY KEY
schema_jsonld   JSONB           -- Full JSON-LD with schema.org @type
source          TEXT            -- imap | manual | api | ai
created_at      TIMESTAMP
content_hash    TEXT            -- For deduplication
```

### Assertions (Postgres)

Assertions represent _all changes_ to the system. No UPDATE or DELETE is permitted.

```sql
-- Table: assertions
assertion_id            UUID PRIMARY KEY
item_id                 UUID REFERENCES items
assertion_type          TEXT            -- Enum: LabelApplied, StatusChanged, etc.
payload_json            JSONB           -- Type-specific data
actor_type              TEXT            -- user | agent | system
actor_id                TEXT            -- User ID or agent name
created_at              TIMESTAMP
supersedes_assertion_id UUID            -- Optional: for corrections
otel_trace_id           TEXT            -- Required for AI assertions
```

**Key assertion types:**

| Type                     | Description                              |
| ------------------------ | ---------------------------------------- |
| `LabelApplied`           | Label added to a Thing                   |
| `LabelRemoved`           | Label removed                            |
| `AssociatedWithCase`     | Thing assigned to a Case                 |
| `RemovedFromCase`        | Thing removed from Case                  |
| `StatusChanged`          | Status update                            |
| `ProposedClassification` | AI suggestion (requires `otel_trace_id`) |
| `ProposalAccepted`       | User accepted AI proposal                |
| `ProposalRejected`       | User rejected AI proposal                |

---

## Write & Read Paths

### Write Path

1. Client sends a write to the API.
2. API validates basic fields and writes to Postgres.
3. In the same transaction, an outbox event is recorded.
4. A projection worker consumes the outbox.
5. The worker indexes the item in Meilisearch (if enabled).

### Read Path

1. All views read from Postgres.
2. Full-text search queries are proxied to Meilisearch.

### Schema.org Compliance

1. A local schema.org profile defines allowed types and required properties.
2. JSON-LD serializers enforce the profile at the application boundary.
3. Validation errors are stored and surfaced for remediation.

### Consistency Model

1. **Postgres is strongly consistent.** Writes are transactional.
2. **Meilisearch is eventually consistent.** Search index lag is expected.

---

## Projections

Projections are _derived views_ over the immutable catalog.

### Vector Index (Qdrant)

Embeddings for semantic search:

- Thing textual fields
- Document attachments

Payload includes: `item_id`, `type`, `labels`, `case_id`, `timestamp`

### Rebuild & Migration

1. Rebuilds are driven from the outbox event stream.
2. A full reindex can regenerate search indices from Postgres.

### Failure Handling

1. Projection failures are retried with backoff.
2. A dead-letter queue stores permanent failures for review.

---

## AI Architecture

### Haystack Pipelines

AI agents for the MVP:

- **Inbox Classifier** — suggests FundingScheme, Case, and Applicant
- **Case Router** — routes items to appropriate cases
- **Knowledge Curator** — promotes valuable content (light)

Each agent:

- Reads Things + recent assertions
- Produces _proposal assertions only_
- May abstain (no forced output)
- Logs all inputs/outputs via OpenTelemetry

### LLM via OpenRouter

- Model routing configurable per agent
- Prompt + model version logged
- Token and latency metadata in OTEL spans

### AI Constraints (MVP)

1. AI assists with comparison only — it does not decide
2. AI never finalizes decisions — all require human confirmation
3. AI outputs are explainable and traceable
4. System remains fully usable with AI disabled

---

## Observability & Traceability

**Observability is a core system feature, not an operational afterthought.**

### OpenTelemetry Context

All requests propagate:

- `user_id`
- `session_id`
- `request_id`

Attached to:

- OTEL spans
- Logs
- Metrics
- AI proposal assertions (`otel_trace_id`)

### Supervision UI

Every AI proposal includes `otel_trace_id` for navigating to:

- Full trace in Grafana/Tempo
- Input/output inspection
- Model and prompt versions
- Token usage and latency

**Requirement:** AI supervision is reachable from any AI-touched item in ≤2 clicks.

---

## Test Harness

### World Packs (Fixtures)

```
fixtures/worlds/<world_id>/
  world.yaml          # World definition
  items/              # Item JSON-LD files
  assertions/         # Assertion sequence
  blobs/              # Attachments
  imap/               # Mock emails (ElektroMail format)
  ai/                 # Stubbed AI responses
```

World packs define a complete, deterministic system state.

### Frontend Testing

| Level       | Tool            | Purpose            |
| ----------- | --------------- | ------------------ |
| Unit        | Vitest          | Component logic    |
| Component   | Testing Library | DOM interaction    |
| Integration | MSW             | Mocked API         |
| E2E         | Playwright      | Full user journeys |

### Backend Testing

| Level       | Tool           | Purpose           |
| ----------- | -------------- | ----------------- |
| Unit        | pytest         | Business logic    |
| API         | pytest + httpx | Endpoint behavior |
| Integration | World packs    | Full system state |

### Dev Harness

Enabled in dev/test only:

```
POST /__dev/reset           # Reset database
POST /__dev/load_world      # Load fixture world
POST /__dev/inject_email    # Add email to inbox
POST /__dev/set_ai_mode     # off | stub | live
```

Frontend harness route `/__harness` provides UI for:

- World selection and loading
- Item injection
- AI mode toggling

---

## Operational Notes

1. The projection worker is stateless and can be scaled horizontally.
2. Search index rebuilds are safe because they are derived from Postgres.

---

## Related Documentation

- [Data Model](?path=/docs/engineering-ontology--docs) — Schema.org-first data model (entities, properties, JSON-LD)
- [Schema.org Vocabulary](?path=/docs/engineering-ontology-schema-org-vocabulary--docs) — Full schema.org type catalog
- [Agents Service](?path=/docs/engineering-agents-service--docs) — Tay copilot: setup, configuration, delegated auth, tool execution
- [LLM Evaluation](?path=/docs/engineering-llm-evaluation--docs) — Golden dataset, LLM cache, trace files, evaluation layers
- [Product Vision](?path=/docs/product-product-vision--docs) — Product scope and methodology
- [Deployment](?path=/docs/engineering-deployment--docs) — Container structure and CI/CD
