import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/Backend Architecture" />

# Backend Architecture

This backend design uses a dual-store model:

1. **Postgres is the system of record** for all raw items and catalog facts (files, notes, recordings, web-scraped data, and user edits).
2. **Apache Jena Fuseki is the semantic projection** for relationships, types, and schema.org-aligned structure.

The graph store is derived and can always be rebuilt from Postgres. It is not authoritative.

---

## Goals

1. Keep a durable, auditable catalog of everything in Postgres.
2. Enforce schema.org alignment and rich relationships in the graph.
3. Allow evolution of the schema profile without data loss.
4. Support fast list and search operations from Postgres.
5. Support graph traversal and semantic queries from Fuseki.

---

## Core Invariants

1. **Postgres is source of truth.** No direct writes to Fuseki that are not also written to Postgres.
2. **Stable canonical IDs.** Every item has a single canonical `@id` used across both stores.
3. **One-way projection.** Data flows from Postgres to Fuseki only.
4. **Rebuildable graph.** The graph can be regenerated from Postgres events.

---

## Data Stores

**Postgres (catalog store)**

1. Raw items and facts.
2. User edits and refinements.
3. Attachments and metadata.
4. Event outbox for projection.

**Fuseki (semantic store)**

1. JSON-LD projected as RDF.
2. Schema.org typing and relationships.
3. SHACL validation as quality gate.
4. SPARQL query surface for graph traversal.

---

## Write Path

1. Client sends a write to the API.
2. API validates basic fields and writes to Postgres.
3. In the same transaction, an outbox event is recorded.
4. A projection worker consumes the outbox.
5. The worker converts the item to JSON-LD.
6. The JSON-LD is validated against SHACL.
7. If valid, the worker upserts to Fuseki.
8. If invalid, the worker records a validation error and leaves the graph unchanged.

This preserves Postgres durability while enforcing schema.org compliance in the graph.

---

## Read Path

1. Catalog and list views read from Postgres.
2. Relationship-heavy views read from Fuseki.
3. Cross-store joins are done in the application layer using canonical IDs.

---

## Schema.org Compliance

1. A local schema.org profile defines allowed types and required properties.
2. JSON-LD serializers enforce the profile at the application boundary.
3. SHACL shapes enforce the profile at the graph boundary.
4. Validation errors are stored and surfaced for remediation.

---

## Consistency Model

1. **Postgres is strong consistency.** Writes are transactional.
2. **Fuseki is eventually consistent.** Projection lag is expected.
3. **No bi-directional sync.** The graph does not write back to Postgres.

---

## Rebuild and Migration Strategy

1. Rebuilds are driven from the outbox event stream.
2. A full reindex can be run to regenerate the graph from Postgres.
3. Schema profile changes are applied by re-validating and re-projecting.

---

## Failure Handling

1. SHACL validation failures do not block Postgres writes.
2. Invalid items are flagged and retried after fixes.
3. Projection failures are retried with backoff.
4. A dead-letter queue stores permanent failures for review.

---

## Operational Notes

1. Fuseki runs with TDB2 for persistence.
2. SHACL validation can use the Jena SHACL API or a Fuseki SHACL endpoint.
3. The projection worker is stateless and can be scaled horizontally.
4. Graph rebuilds are safe because the graph is derived.

---

## Open Decisions

1. Should SHACL failures ever block a Postgres write in high-integrity domains?
2. Which entities are projected immediately versus on-demand?
3. How much of the graph is materialized versus computed?

---

## Summary

Postgres is the durable catalog and system of record. Fuseki is the semantic graph and compliance boundary. A one-way projection pipeline with SHACL validation keeps the graph aligned to schema.org while preserving the flexibility of a catalog-first architecture.
