import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Engineering/ADR/003 TanStack Query as State Layer" />

# ADR-003: TanStack Query as Sole State Management

**Status:** Accepted

---

## Context

The frontend needs to manage:

- Server state (items, projects, references fetched from the API)
- Cache invalidation and optimistic updates
- Derived views (inbox items, actions, projects — all filters over the same data)

Common approaches include Redux, Zustand, MobX, or dedicated server-state libraries.

## Decision

Use **TanStack Query v5** as the sole state management layer. No Redux, Zustand,
or other global state library.

- All server data lives in the TanStack Query cache
- Derived views are computed via `useMemo` in thin hook wrappers (e.g., `useInboxItems`
  filters `useAllItems` by bucket)
- Mutations use `useMutation` with `onSettled` cache invalidation
- Minimal local UI state uses React's `useState` / `useReducer`

## Consequences

**Positive:**

- Single source of truth for server state with built-in caching, refetching, and
  stale-while-revalidate
- No action/reducer/selector boilerplate
- Optimistic updates via `onMutate` / `onSettled` are straightforward
- DevTools (TanStack Query DevTools) provide cache inspection out of the box

**Negative:**

- Complex cross-cutting client-only state (if ever needed) would require adding a
  lightweight store — not needed so far
- Team members familiar with Redux need to adapt to the query/mutation mental model
- Cache invalidation must be done carefully to avoid stale UI after mutations

---

## Related

- [Architecture](?path=/docs/engineering-architecture--docs) — Frontend stack overview
- [Testing](?path=/docs/engineering-testing--docs) — MSW + TanStack Query test patterns
