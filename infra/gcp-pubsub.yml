---
# Ansible playbook: Set up Gmail Pub/Sub infrastructure
#
# Creates topic, subscription, service account, and IAM bindings
# needed for Gmail push notifications via Pub/Sub.
#
# Uses gcloud CLI (no ADC required — works with `gcloud auth login`).
#
# Usage:
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_account=you@example.com
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_auto_auth_login=true
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_org_id=123456789012 \
#     -e gcp_configure_managed_allowed_policy_members=true \
#     -e gcp_managed_policy_scope=project
#   # Optional: include production rollout (k8s secret patch + restarts) on senticor000
#   ansible-playbook -i ../infrastructure/ansible/inventories/production.yml infra/gcp-pubsub.yml \
#     -e gcp_project=senticor-project \
#     -e gcp_rollout_enabled=true \
#     -e gcp_rollout_oauth_client_secret_file=env-config/client_secret_*.json
#
# Re-run safely — all tasks are idempotent.

- name: Gmail Pub/Sub setup
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    gcp_project: "{{ gcp_project }}"
    gcp_org_id: "{{ gcp_org_id | default('') }}"
    gcp_account_input: "{{ gcp_account | default('') }}"
    gcp_auto_auth_login_enabled: "{{ (gcp_auto_auth_login | default(false)) | bool }}"
    gcp_configure_managed_allowed_policy_members_enabled: "{{ (gcp_configure_managed_allowed_policy_members | default(false)) | bool }}"
    gcp_managed_policy_scope: "{{ gcp_managed_policy_scope | default('project') }}"
    gcp_allowed_member_subjects_extra_list: "{{ gcp_allowed_member_subjects_extra | default([]) }}"
    gcp_allowed_principal_sets_extra_list: "{{ gcp_allowed_principal_sets_extra | default([]) }}"
    topic_name: gmail-push
    subscription_name: gmail-push-sub
    service_account_name: gmail-push-sub
    credentials_dest: "{{ playbook_dir }}/../tmp/{{ gcp_project }}-pubsub-sa.json"
    gmail_publisher: "serviceAccount:gmail-api-push@system.gserviceaccount.com"
    sa_email: "{{ service_account_name }}@{{ gcp_project }}.iam.gserviceaccount.com"
    sa_member: "serviceAccount:{{ sa_email }}"
    full_topic: "projects/{{ gcp_project }}/topics/{{ topic_name }}"
    full_sub: "projects/{{ gcp_project }}/subscriptions/{{ subscription_name }}"

  tasks:
    # ── 0. gcloud auth preflight ──────────────────────────────────────────────
    - name: Assert gcp_project variable is provided
      ansible.builtin.assert:
        that:
          - gcp_project | length > 0
        fail_msg: "Set gcp_project, e.g. -e gcp_project=senticor-project"

    - name: Check gcloud CLI is available
      ansible.builtin.command:
        cmd: "gcloud --version"
      changed_when: false

    - name: Read authenticated gcloud accounts
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list
      changed_when: false

    - name: Parse gcloud auth state
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"

    - name: Fail when no authenticated account and auto-login disabled
      ansible.builtin.fail:
        msg: >-
          No authenticated gcloud account found.
          Run `gcloud auth login --update-adc` manually, or re-run with
          -e gcp_auto_auth_login=true to let this playbook try interactive login.
      when:
        - gcloud_account_names | length == 0
        - not gcp_auto_auth_login_enabled

    - name: Attempt gcloud login when no account exists (non-interactive flow)
      ansible.builtin.command:
        cmd: >-
          gcloud auth login
          {{ gcp_account_input if gcp_account_input | length > 0 else '' }}
          --update-adc
          --no-launch-browser
      register: gcloud_login_initial
      changed_when: true
      failed_when: false
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled

    - name: Fail when interactive login attempt failed
      ansible.builtin.fail:
        msg: >-
          `gcloud auth login --no-launch-browser` failed (rc={{ gcloud_login_initial.rc }}).
          In non-interactive Ansible execution you must complete auth manually in your shell:
          `gcloud auth login {{ gcp_account_input if gcp_account_input | length > 0 else '' }} --update-adc`
          stderr: {{ gcloud_login_initial.stderr | default('') }}
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc != 0

    - name: Refresh authenticated gcloud accounts after initial login
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list_post_login
      changed_when: false
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc == 0

    - name: Update account facts after initial login
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list_post_login.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list_post_login.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list_post_login.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc == 0

    - name: Fail when requested gcp_account is not authenticated and auto-login disabled
      ansible.builtin.fail:
        msg: >-
          Requested gcp_account={{ gcp_account_input }} is not authenticated.
          Authenticated accounts: {{ gcloud_account_names | join(', ') if gcloud_account_names else 'none' }}.
          Run `gcloud auth login {{ gcp_account_input }} --update-adc`, or re-run with
          -e gcp_auto_auth_login=true.
      when:
        - gcp_account_input | length > 0
        - gcp_account_input not in gcloud_account_names
        - not gcp_auto_auth_login_enabled

    - name: Attempt gcloud login for requested account (non-interactive flow)
      ansible.builtin.command:
        cmd: "gcloud auth login {{ gcp_account_input }} --update-adc --no-launch-browser"
      register: gcloud_login_requested
      changed_when: true
      failed_when: false
      when:
        - gcp_account_input | length > 0
        - gcp_account_input not in gcloud_account_names
        - gcp_auto_auth_login_enabled

    - name: Fail when requested-account login attempt failed
      ansible.builtin.fail:
        msg: >-
          `gcloud auth login {{ gcp_account_input }} --no-launch-browser` failed (rc={{ gcloud_login_requested.rc }}).
          In non-interactive Ansible execution you must complete auth manually in your shell:
          `gcloud auth login {{ gcp_account_input }} --update-adc`
          stderr: {{ gcloud_login_requested.stderr | default('') }}
      when:
        - gcp_account_input | length > 0
        - gcp_account_input not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc != 0

    - name: Refresh authenticated gcloud accounts after requested-account login
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list_post_requested
      changed_when: false
      when:
        - gcp_account_input | length > 0
        - gcp_account_input not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc == 0

    - name: Update account facts after requested-account login
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list_post_requested.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list_post_requested.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list_post_requested.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"
      when:
        - gcp_account_input | length > 0
        - gcp_account_input not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc == 0

    - name: Select gcloud account for this run
      ansible.builtin.set_fact:
        gcloud_selected_account: >-
          {{
            gcp_account_input
            if gcp_account_input | length > 0
            else (
              gcloud_active_accounts[0]
              if gcloud_active_accounts | length > 0
              else (
                gcloud_account_names[0]
                if gcloud_account_names | length > 0
                else ''
              )
            )
          }}

    - name: Fail when no usable gcloud account is available
      ansible.builtin.fail:
        msg: "No usable gcloud account found after auth preflight."
      when: gcloud_selected_account | length == 0

    - name: Set active gcloud account for this run
      ansible.builtin.command:
        cmd: "gcloud config set account {{ gcloud_selected_account }}"
      changed_when: false

    - name: Validate selected account can mint access token
      ansible.builtin.command:
        cmd: "gcloud auth print-access-token --account={{ gcloud_selected_account }} --quiet"
      register: gcloud_token_check
      changed_when: false
      failed_when: false

    - name: Attempt reauthentication when token check fails (non-interactive flow)
      ansible.builtin.command:
        cmd: "gcloud auth login {{ gcloud_selected_account }} --update-adc --no-launch-browser"
      register: gcloud_reauth
      changed_when: true
      failed_when: false
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled

    - name: Re-check token after reauthentication attempt
      ansible.builtin.command:
        cmd: "gcloud auth print-access-token --account={{ gcloud_selected_account }} --quiet"
      register: gcloud_token_check_after
      changed_when: false
      failed_when: false
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled
        - gcloud_reauth.rc == 0

    - name: Fail when token check fails and auto-login is disabled
      ansible.builtin.fail:
        msg: >-
          Active account {{ gcloud_selected_account }} cannot refresh auth token.
          Run `gcloud auth login {{ gcloud_selected_account }} --update-adc` and re-run,
          or use -e gcp_auto_auth_login=true.
      when:
        - gcloud_token_check.rc != 0
        - not gcp_auto_auth_login_enabled

    - name: Fail when token check still fails after reauthentication attempt
      ansible.builtin.fail:
        msg: >-
          Account {{ gcloud_selected_account }} still cannot mint an access token
          after `gcloud auth login --no-launch-browser` (rc={{ gcloud_reauth.rc | default('n/a') }}).
          Run this manually in your shell, then re-run the playbook:
          `gcloud auth login {{ gcloud_selected_account }} --update-adc`
          stderr: {{ gcloud_reauth.stderr | default(gcloud_token_check.stderr | default('')) }}
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled
        - gcloud_reauth.rc != 0 or gcloud_token_check_after.rc != 0

    - name: Set gcloud project for this run
      ansible.builtin.command:
        cmd: "gcloud config set project {{ gcp_project }}"
      changed_when: false

    - name: Auth preflight summary
      ansible.builtin.debug:
        msg:
          - "Using gcloud account: {{ gcloud_selected_account }}"
          - "Using gcloud project: {{ gcp_project }}"

    # ── 0b. Optional org-policy prerequisite setup ───────────────────────────
    - name: Assert managed policy scope value is valid
      ansible.builtin.assert:
        that:
          - gcp_managed_policy_scope in ['project', 'organization']
        fail_msg: >-
          Invalid gcp_managed_policy_scope={{ gcp_managed_policy_scope }}.
          Use -e gcp_managed_policy_scope=project or -e gcp_managed_policy_scope=organization.
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Assert gcp_org_id is set when managed policy automation is enabled
      ansible.builtin.assert:
        that:
          - gcp_org_id | length > 0
        fail_msg: >-
          Set gcp_org_id (numeric org ID), e.g. -e gcp_org_id=126678810646
          when using -e gcp_configure_managed_allowed_policy_members=true.
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Get project number for project-scoped managed policy
      ansible.builtin.command:
        cmd: "gcloud projects describe {{ gcp_project }} --format=value(projectNumber)"
      register: gcp_project_number_for_managed_policy
      changed_when: false
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'project'

    - name: Set managed policy resource name for organization scope
      ansible.builtin.set_fact:
        managed_allowed_policy_name: "organizations/{{ gcp_org_id }}/policies/iam.managed.allowedPolicyMembers"
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'organization'

    - name: Set managed policy resource name for project scope
      ansible.builtin.set_fact:
        managed_allowed_policy_name: >-
          projects/{{ gcp_project_number_for_managed_policy.stdout | trim }}/policies/iam.managed.allowedPolicyMembers
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'project'

    - name: Build allowed members/principal sets for managed domain restriction
      ansible.builtin.set_fact:
        managed_allowed_member_subjects: >-
          {{
            ([gmail_publisher] + (gcp_allowed_member_subjects_extra_list | list)) | unique
          }}
        managed_allowed_principal_sets: >-
          {{
            (
              ['//cloudresourcemanager.googleapis.com/organizations/' ~ gcp_org_id]
              + (gcp_allowed_principal_sets_extra_list | list)
            ) | unique
          }}
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Build managed policy document
      ansible.builtin.set_fact:
        managed_allowed_policy_doc:
          name: "{{ managed_allowed_policy_name }}"
          spec:
            rules:
              - enforce: true
                parameters:
                  allowedMemberSubjects: "{{ managed_allowed_member_subjects }}"
                  allowedPrincipalSets: "{{ managed_allowed_principal_sets }}"
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Create temp file for managed allowedPolicyMembers policy
      ansible.builtin.tempfile:
        state: file
        prefix: managed-allowed-policy-members-
        suffix: .yaml
      register: managed_policy_file
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Write managed allowedPolicyMembers policy file
      ansible.builtin.copy:
        dest: "{{ managed_policy_file.path }}"
        content: "{{ managed_allowed_policy_doc | to_nice_yaml }}"
        mode: "0600"
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Apply iam.managed.allowedPolicyMembers policy
      ansible.builtin.command:
        cmd: >-
          gcloud org-policies set-policy {{ managed_policy_file.path }}
          --update-mask=spec
      register: apply_managed_policy
      changed_when: true
      failed_when: false
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Fail with guidance when managed policy apply is denied
      ansible.builtin.fail:
        msg: >-
          Failed to apply managed policy {{ managed_allowed_policy_name }}.
          gcloud stderr: {{ apply_managed_policy.stderr | default('') }}
          If this is IAM_PERMISSION_DENIED, grant roles/orgpolicy.policyAdmin
          on an ancestor resource (organization or folder) that contains project {{ gcp_project }},
          then re-run with an account that has that inherited permission.
          Note: roles/orgpolicy.policyAdmin is not grantable directly on projects.
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - apply_managed_policy.rc != 0

    - name: Managed policy setup summary
      ansible.builtin.debug:
        msg:
          - "Applied managed policy scope: {{ gcp_managed_policy_scope }}"
          - "Policy resource: {{ managed_allowed_policy_name }}"
          - "Allowed member subjects: {{ managed_allowed_member_subjects | join(', ') }}"
          - "Allowed principal sets: {{ managed_allowed_principal_sets | join(', ') }}"
      when: gcp_configure_managed_allowed_policy_members_enabled

    # ── 0c. Ensure Pub/Sub API is enabled ────────────────────────────────────
    - name: Check whether Pub/Sub API is enabled
      ansible.builtin.command:
        cmd: >-
          gcloud services list --enabled
          --project={{ gcp_project }}
          --filter=name:pubsub.googleapis.com
          --format=value(name)
      register: pubsub_api_enabled_check
      changed_when: false

    - name: Enable Pub/Sub API
      ansible.builtin.command:
        cmd: "gcloud services enable pubsub.googleapis.com --project={{ gcp_project }}"
      when: (pubsub_api_enabled_check.stdout | trim) != "pubsub.googleapis.com"
      changed_when: true

    # ── 1. Pub/Sub topic ────────────────────────────────────────────────
    - name: Check if topic exists
      ansible.builtin.command:
        cmd: "gcloud pubsub topics describe {{ full_topic }} --project={{ gcp_project }} --format=value(name)"
      register: topic_check
      changed_when: false
      failed_when: false

    - name: Create Pub/Sub topic
      ansible.builtin.command:
        cmd: "gcloud pubsub topics create {{ topic_name }} --project={{ gcp_project }}"
      when: topic_check.rc != 0
      changed_when: true

    - name: Topic status
      ansible.builtin.debug:
        msg: "{{ 'Created' if topic_check.rc != 0 else 'Exists' }}: {{ full_topic }}"

    # ── 2. Gmail publish permission on topic ────────────────────────────
    - name: Check Gmail publisher IAM binding
      ansible.builtin.command:
        cmd: "gcloud pubsub topics get-iam-policy {{ full_topic }} --project={{ gcp_project }} --format=json"
      register: topic_iam_raw
      changed_when: false

    - name: Parse topic IAM policy
      ansible.builtin.set_fact:
        topic_has_gmail_publisher: >-
          {{
            (topic_iam_raw.stdout | from_json).get('bindings', [])
            | selectattr('role', 'equalto', 'roles/pubsub.publisher')
            | map(attribute='members')
            | flatten
            | select('equalto', gmail_publisher)
            | list
            | length > 0
          }}

    - name: Grant Gmail publisher role on topic
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub topics add-iam-policy-binding {{ full_topic }}
          --member={{ gmail_publisher }}
          --role=roles/pubsub.publisher
          --project={{ gcp_project }}
      register: grant_gmail_publisher
      when: not topic_has_gmail_publisher
      changed_when: true
      failed_when: false

    - name: Fail with actionable guidance when domain-restricted sharing blocks Gmail publisher
      ansible.builtin.fail:
        msg: >-
          Could not grant {{ gmail_publisher }} on {{ full_topic }}.
          gcloud stderr: {{ grant_gmail_publisher.stderr | default('') }}
          This is usually blocked by org policy `constraints/iam.allowedPolicyMemberDomains`.
          Gmail push requires this principal to publish to Pub/Sub.
          Ask an Org Policy Admin to migrate domain-restricted sharing to
          `iam.managed.allowedPolicyMembers` (or custom AllowPolicy) and allow
          `serviceAccount:gmail-api-push@system.gserviceaccount.com`.
      when:
        - not topic_has_gmail_publisher
        - grant_gmail_publisher.rc != 0

    # ── 3. Pub/Sub subscription ─────────────────────────────────────────
    - name: Check if subscription exists
      ansible.builtin.command:
        cmd: "gcloud pubsub subscriptions describe {{ full_sub }} --project={{ gcp_project }} --format=value(name)"
      register: sub_check
      changed_when: false
      failed_when: false

    - name: Create Pub/Sub subscription
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub subscriptions create {{ subscription_name }}
          --topic={{ topic_name }}
          --ack-deadline=30
          --project={{ gcp_project }}
      when: sub_check.rc != 0
      changed_when: true

    - name: Subscription status
      ansible.builtin.debug:
        msg: "{{ 'Created' if sub_check.rc != 0 else 'Exists' }}: {{ full_sub }}"

    # ── 4. Service account ──────────────────────────────────────────────
    - name: Check if service account exists
      ansible.builtin.command:
        cmd: "gcloud iam service-accounts describe {{ sa_email }} --project={{ gcp_project }} --format=value(email)"
      register: sa_check
      changed_when: false
      failed_when: false

    - name: Create service account
      ansible.builtin.command:
        cmd: >-
          gcloud iam service-accounts create {{ service_account_name }}
          --display-name="Gmail Push Subscriber"
          --project={{ gcp_project }}
      when: sa_check.rc != 0
      changed_when: true

    - name: Service account status
      ansible.builtin.debug:
        msg: "{{ 'Created' if sa_check.rc != 0 else 'Exists' }}: {{ sa_email }}"

    # ── 5. Subscriber permission on subscription ────────────────────────
    - name: Check subscriber IAM binding
      ansible.builtin.command:
        cmd: "gcloud pubsub subscriptions get-iam-policy {{ full_sub }} --project={{ gcp_project }} --format=json"
      register: sub_iam_raw
      changed_when: false

    - name: Parse subscription IAM policy
      ansible.builtin.set_fact:
        sub_has_subscriber: >-
          {{
            (sub_iam_raw.stdout | from_json).get('bindings', [])
            | selectattr('role', 'equalto', 'roles/pubsub.subscriber')
            | map(attribute='members')
            | flatten
            | select('equalto', sa_member)
            | list
            | length > 0
          }}

    - name: Grant subscriber role on subscription
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub subscriptions add-iam-policy-binding {{ full_sub }}
          --member={{ sa_member }}
          --role=roles/pubsub.subscriber
          --project={{ gcp_project }}
      register: grant_subscriber_binding
      when: not sub_has_subscriber
      changed_when: true
      retries: 10
      delay: 3
      until: grant_subscriber_binding.rc == 0

    # ── 6. Service account key ──────────────────────────────────────────
    - name: Check if credentials file exists
      ansible.builtin.stat:
        path: "{{ credentials_dest }}"
      register: creds_file

    - name: Validate existing credentials file JSON
      ansible.builtin.command:
        cmd: >-
          python3 -c "import json,sys; d=json.load(open(sys.argv[1]));
          req=['type','project_id','private_key_id','private_key','client_email','client_id'];
          missing=[k for k in req if not d.get(k)];
          raise SystemExit(1 if missing else 0)" {{ credentials_dest }}
      register: creds_file_check
      changed_when: false
      failed_when: false
      when: creds_file.stat.exists

    - name: Determine whether credentials file is usable
      ansible.builtin.set_fact:
        creds_file_valid: "{{ (creds_file.stat.exists | bool) and ((creds_file_check.rc | default(1)) == 0) }}"

    - name: Remove invalid credentials file before regenerating
      ansible.builtin.file:
        path: "{{ credentials_dest }}"
        state: absent
      when:
        - creds_file.stat.exists
        - not creds_file_valid

    - name: Create service account key
      ansible.builtin.command:
        cmd: >-
          gcloud iam service-accounts keys create {{ credentials_dest }}
          --iam-account={{ sa_email }}
          --project={{ gcp_project }}
      when: not creds_file_valid
      changed_when: true

    - name: Protect credentials file
      ansible.builtin.file:
        path: "{{ credentials_dest }}"
        mode: "0600"

    - name: Expose generated credentials path for optional rollout play
      ansible.builtin.set_fact:
        gcp_pubsub_credentials_dest_fact: "{{ credentials_dest }}"

    # ── 7. Summary ──────────────────────────────────────────────────────
    - name: Print .env configuration
      ansible.builtin.debug:
        msg: |
          Add to .env:

          GMAIL_PUBSUB_PROJECT_ID={{ gcp_project }}
          GMAIL_PUBSUB_TOPIC={{ full_topic }}
          GMAIL_PUBSUB_SUBSCRIPTION={{ subscription_name }}
          GMAIL_PUBSUB_CREDENTIALS_FILE=tmp/{{ gcp_project }}-pubsub-sa.json

- name: Optional Gmail Pub/Sub production rollout on senticor000
  hosts: "{{ gcp_rollout_hosts | default('senticor000') }}"
  become: true
  gather_facts: false

  vars:
    rollout_enabled: "{{ (gcp_rollout_enabled | default(false)) | bool }}"
    rollout_kubeconfig: "{{ gcp_rollout_kubeconfig | default('/etc/rancher/k3s/k3s.yaml') }}"
    rollout_namespace: "{{ gcp_rollout_namespace | default('project') }}"
    rollout_pubsub_secret_name: "{{ gcp_rollout_pubsub_secret_name | default('pubsub-sa') }}"
    rollout_pubsub_secret_key: "{{ gcp_rollout_pubsub_secret_key | default('pubsub-sa.json') }}"
    rollout_app_secret_name: "{{ gcp_rollout_app_secret_name | default('app-secrets') }}"
    rollout_flux_namespace: "{{ gcp_rollout_flux_namespace | default('flux-system') }}"
    rollout_flux_source: "{{ gcp_rollout_flux_source | default('project') }}"
    rollout_flux_kustomization: "{{ gcp_rollout_flux_kustomization | default('project') }}"
    rollout_flux_reconcile: "{{ (gcp_rollout_flux_reconcile | default(true)) | bool }}"
    rollout_deployments: "{{ gcp_rollout_deployments | default(['backend', 'worker', 'watch-worker']) }}"
    rollout_oauth_client_secret_file: "{{ gcp_rollout_oauth_client_secret_file | default('') }}"
    rollout_state_secret: "{{ gcp_rollout_gmail_state_secret | default('') }}"
    rollout_encryption_key: "{{ gcp_rollout_encryption_key | default('') }}"
    rollout_pubsub_credentials_file: "{{ gcp_rollout_pubsub_credentials_file | default(hostvars['localhost'].gcp_pubsub_credentials_dest_fact | default('')) }}"
    rollout_remote_tmp_dir: /tmp/project-gmail-rollout

  environment:
    KUBECONFIG: "{{ rollout_kubeconfig }}"

  tasks:
    - name: Validate rollout OAuth credentials file argument is set
      ansible.builtin.assert:
        that:
          - rollout_oauth_client_secret_file | length > 0
        fail_msg: >-
          Set gcp_rollout_oauth_client_secret_file=/absolute/path/client_secret*.json
          when using -e gcp_rollout_enabled=true.
      run_once: true
      when: rollout_enabled

    - name: Check rollout OAuth credentials file exists locally
      ansible.builtin.stat:
        path: "{{ rollout_oauth_client_secret_file }}"
      delegate_to: localhost
      become: false
      run_once: true
      register: rollout_oauth_file
      when: rollout_enabled

    - name: Validate rollout OAuth credentials file exists
      ansible.builtin.assert:
        that:
          - rollout_oauth_file.stat.exists
        fail_msg: "Missing file: {{ rollout_oauth_client_secret_file }}"
      run_once: true
      when: rollout_enabled

    - name: Extract Gmail OAuth credentials from client secret file
      ansible.builtin.shell: |
        set -euo pipefail
        python3 - <<'PY' "{{ rollout_oauth_client_secret_file }}"
        import json
        import sys

        path = sys.argv[1]
        with open(path, "r", encoding="utf-8") as handle:
            data = json.load(handle)

        root = "web" if "web" in data else "installed" if "installed" in data else None
        if root is None:
            raise SystemExit("Expected top-level key 'web' or 'installed' in OAuth client JSON")

        client_id = (data[root].get("client_id") or "").strip()
        client_secret = (data[root].get("client_secret") or "").strip()

        if not client_id or not client_secret:
            raise SystemExit("OAuth client JSON is missing client_id or client_secret")

        print(json.dumps({"client_id": client_id, "client_secret": client_secret}))
        PY
      args:
        executable: /bin/bash
      delegate_to: localhost
      become: false
      run_once: true
      register: rollout_oauth_values
      changed_when: false
      no_log: true
      when: rollout_enabled

    - name: Store extracted OAuth values for rollout
      ansible.builtin.set_fact:
        gcp_rollout_client_id_fact: "{{ (rollout_oauth_values.stdout | from_json).client_id }}"
        gcp_rollout_client_secret_fact: "{{ (rollout_oauth_values.stdout | from_json).client_secret }}"
      delegate_to: localhost
      delegate_facts: true
      become: false
      run_once: true
      no_log: true
      when: rollout_enabled

    - name: Validate Pub/Sub credentials file path is set for rollout
      ansible.builtin.assert:
        that:
          - rollout_pubsub_credentials_file | length > 0
        fail_msg: >-
          Could not determine Pub/Sub service-account key file.
          Set gcp_rollout_pubsub_credentials_file=/absolute/path/<project>-pubsub-sa.json
          when using -e gcp_rollout_enabled=true.
      run_once: true
      when: rollout_enabled

    - name: Check rollout Pub/Sub credentials file exists locally
      ansible.builtin.stat:
        path: "{{ rollout_pubsub_credentials_file }}"
      delegate_to: localhost
      become: false
      run_once: true
      register: rollout_pubsub_file
      when: rollout_enabled

    - name: Validate rollout Pub/Sub credentials file exists
      ansible.builtin.assert:
        that:
          - rollout_pubsub_file.stat.exists
        fail_msg: "Missing file: {{ rollout_pubsub_credentials_file }}"
      run_once: true
      when: rollout_enabled

    - name: Check target app-secrets exists
      ansible.builtin.command:
        argv:
          - kubectl
          - -n
          - "{{ rollout_namespace }}"
          - get
          - secret
          - "{{ rollout_app_secret_name }}"
          - -o
          - name
      register: rollout_app_secret_check
      changed_when: false
      failed_when: rollout_app_secret_check.rc != 0
      when: rollout_enabled

    - name: Build base app-secrets patch map
      ansible.builtin.set_fact:
        rollout_app_secret_patch_map:
          GMAIL_CLIENT_ID: "{{ hostvars['localhost'].gcp_rollout_client_id_fact }}"
          GMAIL_CLIENT_SECRET: "{{ hostvars['localhost'].gcp_rollout_client_secret_fact }}"
      no_log: true
      when: rollout_enabled

    - name: Add optional GMAIL_STATE_SECRET to app-secrets patch
      ansible.builtin.set_fact:
        rollout_app_secret_patch_map: "{{ rollout_app_secret_patch_map | combine({'GMAIL_STATE_SECRET': rollout_state_secret}) }}"
      no_log: true
      when:
        - rollout_enabled
        - rollout_state_secret | length > 0

    - name: Add optional ENCRYPTION_KEY to app-secrets patch
      ansible.builtin.set_fact:
        rollout_app_secret_patch_map: "{{ rollout_app_secret_patch_map | combine({'ENCRYPTION_KEY': rollout_encryption_key}) }}"
      no_log: true
      when:
        - rollout_enabled
        - rollout_encryption_key | length > 0

    - name: Apply production rollout changes
      when: rollout_enabled
      block:
        - name: Ensure remote temp directory exists
          ansible.builtin.file:
            path: "{{ rollout_remote_tmp_dir }}"
            state: directory
            mode: "0700"

        - name: Copy Pub/Sub credentials file to remote host
          ansible.builtin.copy:
            src: "{{ rollout_pubsub_credentials_file }}"
            dest: "{{ rollout_remote_tmp_dir }}/{{ rollout_pubsub_secret_key }}"
            mode: "0600"
          no_log: true

        - name: Apply or update pubsub-sa secret
          ansible.builtin.shell: |
            set -euo pipefail
            kubectl -n "{{ rollout_namespace }}" create secret generic "{{ rollout_pubsub_secret_name }}" \
              --from-file="{{ rollout_pubsub_secret_key }}={{ rollout_remote_tmp_dir }}/{{ rollout_pubsub_secret_key }}" \
              --dry-run=client -o yaml | kubectl apply -f -
          args:
            executable: /bin/bash
          register: rollout_pubsub_secret_apply
          changed_when: "'created' in rollout_pubsub_secret_apply.stdout or 'configured' in rollout_pubsub_secret_apply.stdout"

        - name: Patch app-secrets with Gmail OAuth values
          ansible.builtin.command:
            argv:
              - kubectl
              - -n
              - "{{ rollout_namespace }}"
              - patch
              - secret
              - "{{ rollout_app_secret_name }}"
              - --type=merge
              - -p
              - "{{ {'stringData': rollout_app_secret_patch_map} | to_json }}"
          changed_when: true
          no_log: true

        - name: Reconcile Flux source
          ansible.builtin.command:
            argv:
              - flux
              - reconcile
              - source
              - git
              - "{{ rollout_flux_source }}"
              - -n
              - "{{ rollout_flux_namespace }}"
          changed_when: true
          when: rollout_flux_reconcile

        - name: Reconcile Flux kustomization with source
          ansible.builtin.command:
            argv:
              - flux
              - reconcile
              - kustomization
              - "{{ rollout_flux_kustomization }}"
              - -n
              - "{{ rollout_flux_namespace }}"
              - --with-source
          changed_when: true
          when: rollout_flux_reconcile

        - name: Restart rollout deployments
          ansible.builtin.command:
            argv:
              - kubectl
              - -n
              - "{{ rollout_namespace }}"
              - rollout
              - restart
              - "deployment/{{ item }}"
          loop: "{{ rollout_deployments }}"
          changed_when: true

        - name: Wait for rollout deployments
          ansible.builtin.command:
            argv:
              - kubectl
              - -n
              - "{{ rollout_namespace }}"
              - rollout
              - status
              - "deployment/{{ item }}"
              - --timeout=360s
          loop: "{{ rollout_deployments }}"
          changed_when: false

        - name: Confirm watch-worker has available replicas
          ansible.builtin.shell: |
            set -euo pipefail
            replicas="$(kubectl -n "{{ rollout_namespace }}" get deployment/watch-worker -o jsonpath='{.status.availableReplicas}')"
            if [ -z "$replicas" ] || [ "$replicas" = "0" ]; then
              echo "watch-worker has no available replicas" >&2
              exit 1
            fi
            printf '%s' "$replicas"
          args:
            executable: /bin/bash
          register: rollout_watch_worker_replicas
          changed_when: false

      always:
        - name: Clean up remote rollout temp directory
          ansible.builtin.file:
            path: "{{ rollout_remote_tmp_dir }}"
            state: absent

    - name: Rollout summary
      ansible.builtin.debug:
        msg: >-
          Updated {{ rollout_namespace }}/{{ rollout_pubsub_secret_name }} and
          patched {{ rollout_namespace }}/{{ rollout_app_secret_name }} with Gmail OAuth values.
          Flux reconcile={{ rollout_flux_reconcile }}.
          Restarted {{ rollout_deployments | join(', ') }}.
          watch-worker replicas={{ rollout_watch_worker_replicas.stdout | default('n/a') | trim }}.
      when: rollout_enabled
