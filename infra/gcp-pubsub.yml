---
# Ansible playbook: Set up Gmail Pub/Sub infrastructure
#
# Creates topic, subscription, service account, and IAM bindings
# needed for Gmail push notifications via Pub/Sub.
#
# Uses gcloud CLI (no ADC required — works with `gcloud auth login`).
#
# Usage:
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_account=you@example.com
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_auto_auth_login=true
#   ansible-playbook infra/gcp-pubsub.yml -e gcp_project=procedere -e gcp_org_id=123456789012 \
#     -e gcp_configure_managed_allowed_policy_members=true \
#     -e gcp_managed_policy_scope=project
#
# Re-run safely — all tasks are idempotent.

- name: Gmail Pub/Sub setup
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    gcp_project: "{{ gcp_project }}"
    gcp_org_id: "{{ gcp_org_id | default('') }}"
    gcp_account: "{{ gcp_account | default('') }}"
    gcp_auto_auth_login_enabled: "{{ (gcp_auto_auth_login | default(false)) | bool }}"
    gcp_configure_managed_allowed_policy_members_enabled: "{{ (gcp_configure_managed_allowed_policy_members | default(false)) | bool }}"
    gcp_managed_policy_scope: "{{ gcp_managed_policy_scope | default('project') }}"
    gcp_allowed_member_subjects_extra_list: "{{ gcp_allowed_member_subjects_extra | default([]) }}"
    gcp_allowed_principal_sets_extra_list: "{{ gcp_allowed_principal_sets_extra | default([]) }}"
    topic_name: gmail-push
    subscription_name: gmail-push-sub
    service_account_name: gmail-push-sub
    credentials_dest: "{{ playbook_dir }}/../tmp/{{ gcp_project }}-pubsub-sa.json"
    gmail_publisher: "serviceAccount:gmail-api-push@system.gserviceaccount.com"
    sa_email: "{{ service_account_name }}@{{ gcp_project }}.iam.gserviceaccount.com"
    sa_member: "serviceAccount:{{ sa_email }}"
    full_topic: "projects/{{ gcp_project }}/topics/{{ topic_name }}"
    full_sub: "projects/{{ gcp_project }}/subscriptions/{{ subscription_name }}"

  tasks:
    # ── 0. gcloud auth preflight ──────────────────────────────────────────────
    - name: Assert gcp_project variable is provided
      ansible.builtin.assert:
        that:
          - gcp_project | length > 0
        fail_msg: "Set gcp_project, e.g. -e gcp_project=senticor-project"

    - name: Check gcloud CLI is available
      ansible.builtin.command:
        cmd: "gcloud --version"
      changed_when: false

    - name: Read authenticated gcloud accounts
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list
      changed_when: false

    - name: Parse gcloud auth state
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"

    - name: Fail when no authenticated account and auto-login disabled
      ansible.builtin.fail:
        msg: >-
          No authenticated gcloud account found.
          Run `gcloud auth login --update-adc` manually, or re-run with
          -e gcp_auto_auth_login=true to let this playbook try interactive login.
      when:
        - gcloud_account_names | length == 0
        - not gcp_auto_auth_login_enabled

    - name: Attempt gcloud login when no account exists (non-interactive flow)
      ansible.builtin.command:
        cmd: >-
          gcloud auth login
          {{ gcp_account if gcp_account | length > 0 else '' }}
          --update-adc
          --no-launch-browser
      register: gcloud_login_initial
      changed_when: true
      failed_when: false
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled

    - name: Fail when interactive login attempt failed
      ansible.builtin.fail:
        msg: >-
          `gcloud auth login --no-launch-browser` failed (rc={{ gcloud_login_initial.rc }}).
          In non-interactive Ansible execution you must complete auth manually in your shell:
          `gcloud auth login {{ gcp_account if gcp_account | length > 0 else '' }} --update-adc`
          stderr: {{ gcloud_login_initial.stderr | default('') }}
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc != 0

    - name: Refresh authenticated gcloud accounts after initial login
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list_post_login
      changed_when: false
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc == 0

    - name: Update account facts after initial login
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list_post_login.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list_post_login.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list_post_login.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"
      when:
        - gcloud_account_names | length == 0
        - gcp_auto_auth_login_enabled
        - gcloud_login_initial.rc == 0

    - name: Fail when requested gcp_account is not authenticated and auto-login disabled
      ansible.builtin.fail:
        msg: >-
          Requested gcp_account={{ gcp_account }} is not authenticated.
          Authenticated accounts: {{ gcloud_account_names | join(', ') if gcloud_account_names else 'none' }}.
          Run `gcloud auth login {{ gcp_account }} --update-adc`, or re-run with
          -e gcp_auto_auth_login=true.
      when:
        - gcp_account | length > 0
        - gcp_account not in gcloud_account_names
        - not gcp_auto_auth_login_enabled

    - name: Attempt gcloud login for requested account (non-interactive flow)
      ansible.builtin.command:
        cmd: "gcloud auth login {{ gcp_account }} --update-adc --no-launch-browser"
      register: gcloud_login_requested
      changed_when: true
      failed_when: false
      when:
        - gcp_account | length > 0
        - gcp_account not in gcloud_account_names
        - gcp_auto_auth_login_enabled

    - name: Fail when requested-account login attempt failed
      ansible.builtin.fail:
        msg: >-
          `gcloud auth login {{ gcp_account }} --no-launch-browser` failed (rc={{ gcloud_login_requested.rc }}).
          In non-interactive Ansible execution you must complete auth manually in your shell:
          `gcloud auth login {{ gcp_account }} --update-adc`
          stderr: {{ gcloud_login_requested.stderr | default('') }}
      when:
        - gcp_account | length > 0
        - gcp_account not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc != 0

    - name: Refresh authenticated gcloud accounts after requested-account login
      ansible.builtin.command:
        cmd: "gcloud auth list --format=json"
      register: gcloud_auth_list_post_requested
      changed_when: false
      when:
        - gcp_account | length > 0
        - gcp_account not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc == 0

    - name: Update account facts after requested-account login
      ansible.builtin.set_fact:
        gcloud_accounts: "{{ (gcloud_auth_list_post_requested.stdout | from_json) }}"
        gcloud_account_names: "{{ (gcloud_auth_list_post_requested.stdout | from_json) | map(attribute='account') | list }}"
        gcloud_active_accounts: "{{ (gcloud_auth_list_post_requested.stdout | from_json) | selectattr('status', 'equalto', 'ACTIVE') | map(attribute='account') | list }}"
      when:
        - gcp_account | length > 0
        - gcp_account not in gcloud_account_names
        - gcp_auto_auth_login_enabled
        - gcloud_login_requested.rc == 0

    - name: Select gcloud account for this run
      ansible.builtin.set_fact:
        gcloud_selected_account: >-
          {{
            gcp_account
            if gcp_account | length > 0
            else (
              gcloud_active_accounts[0]
              if gcloud_active_accounts | length > 0
              else (
                gcloud_account_names[0]
                if gcloud_account_names | length > 0
                else ''
              )
            )
          }}

    - name: Fail when no usable gcloud account is available
      ansible.builtin.fail:
        msg: "No usable gcloud account found after auth preflight."
      when: gcloud_selected_account | length == 0

    - name: Set active gcloud account for this run
      ansible.builtin.command:
        cmd: "gcloud config set account {{ gcloud_selected_account }}"
      changed_when: false

    - name: Validate selected account can mint access token
      ansible.builtin.command:
        cmd: "gcloud auth print-access-token --account={{ gcloud_selected_account }} --quiet"
      register: gcloud_token_check
      changed_when: false
      failed_when: false

    - name: Attempt reauthentication when token check fails (non-interactive flow)
      ansible.builtin.command:
        cmd: "gcloud auth login {{ gcloud_selected_account }} --update-adc --no-launch-browser"
      register: gcloud_reauth
      changed_when: true
      failed_when: false
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled

    - name: Re-check token after reauthentication attempt
      ansible.builtin.command:
        cmd: "gcloud auth print-access-token --account={{ gcloud_selected_account }} --quiet"
      register: gcloud_token_check_after
      changed_when: false
      failed_when: false
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled
        - gcloud_reauth.rc == 0

    - name: Fail when token check fails and auto-login is disabled
      ansible.builtin.fail:
        msg: >-
          Active account {{ gcloud_selected_account }} cannot refresh auth token.
          Run `gcloud auth login {{ gcloud_selected_account }} --update-adc` and re-run,
          or use -e gcp_auto_auth_login=true.
      when:
        - gcloud_token_check.rc != 0
        - not gcp_auto_auth_login_enabled

    - name: Fail when token check still fails after reauthentication attempt
      ansible.builtin.fail:
        msg: >-
          Account {{ gcloud_selected_account }} still cannot mint an access token
          after `gcloud auth login --no-launch-browser` (rc={{ gcloud_reauth.rc | default('n/a') }}).
          Run this manually in your shell, then re-run the playbook:
          `gcloud auth login {{ gcloud_selected_account }} --update-adc`
          stderr: {{ gcloud_reauth.stderr | default(gcloud_token_check.stderr | default('')) }}
      when:
        - gcloud_token_check.rc != 0
        - gcp_auto_auth_login_enabled
        - gcloud_reauth.rc != 0 or gcloud_token_check_after.rc != 0

    - name: Set gcloud project for this run
      ansible.builtin.command:
        cmd: "gcloud config set project {{ gcp_project }}"
      changed_when: false

    - name: Auth preflight summary
      ansible.builtin.debug:
        msg:
          - "Using gcloud account: {{ gcloud_selected_account }}"
          - "Using gcloud project: {{ gcp_project }}"

    # ── 0b. Optional org-policy prerequisite setup ───────────────────────────
    - name: Assert managed policy scope value is valid
      ansible.builtin.assert:
        that:
          - gcp_managed_policy_scope in ['project', 'organization']
        fail_msg: >-
          Invalid gcp_managed_policy_scope={{ gcp_managed_policy_scope }}.
          Use -e gcp_managed_policy_scope=project or -e gcp_managed_policy_scope=organization.
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Assert gcp_org_id is set when managed policy automation is enabled
      ansible.builtin.assert:
        that:
          - gcp_org_id | length > 0
        fail_msg: >-
          Set gcp_org_id (numeric org ID), e.g. -e gcp_org_id=126678810646
          when using -e gcp_configure_managed_allowed_policy_members=true.
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Get project number for project-scoped managed policy
      ansible.builtin.command:
        cmd: "gcloud projects describe {{ gcp_project }} --format=value(projectNumber)"
      register: gcp_project_number_for_managed_policy
      changed_when: false
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'project'

    - name: Set managed policy resource name for organization scope
      ansible.builtin.set_fact:
        managed_allowed_policy_name: "organizations/{{ gcp_org_id }}/policies/iam.managed.allowedPolicyMembers"
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'organization'

    - name: Set managed policy resource name for project scope
      ansible.builtin.set_fact:
        managed_allowed_policy_name: >-
          projects/{{ gcp_project_number_for_managed_policy.stdout | trim }}/policies/iam.managed.allowedPolicyMembers
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - gcp_managed_policy_scope == 'project'

    - name: Build allowed members/principal sets for managed domain restriction
      ansible.builtin.set_fact:
        managed_allowed_member_subjects: >-
          {{
            ([gmail_publisher] + (gcp_allowed_member_subjects_extra_list | list)) | unique
          }}
        managed_allowed_principal_sets: >-
          {{
            (
              ['//cloudresourcemanager.googleapis.com/organizations/' ~ gcp_org_id]
              + (gcp_allowed_principal_sets_extra_list | list)
            ) | unique
          }}
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Build managed policy document
      ansible.builtin.set_fact:
        managed_allowed_policy_doc:
          name: "{{ managed_allowed_policy_name }}"
          spec:
            rules:
              - enforce: true
                parameters:
                  allowedMemberSubjects: "{{ managed_allowed_member_subjects }}"
                  allowedPrincipalSets: "{{ managed_allowed_principal_sets }}"
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Create temp file for managed allowedPolicyMembers policy
      ansible.builtin.tempfile:
        state: file
        prefix: managed-allowed-policy-members-
        suffix: .yaml
      register: managed_policy_file
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Write managed allowedPolicyMembers policy file
      ansible.builtin.copy:
        dest: "{{ managed_policy_file.path }}"
        content: "{{ managed_allowed_policy_doc | to_nice_yaml }}"
        mode: "0600"
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Apply iam.managed.allowedPolicyMembers policy
      ansible.builtin.command:
        cmd: >-
          gcloud org-policies set-policy {{ managed_policy_file.path }}
          --update-mask=spec
      register: apply_managed_policy
      changed_when: true
      failed_when: false
      when: gcp_configure_managed_allowed_policy_members_enabled

    - name: Fail with guidance when managed policy apply is denied
      ansible.builtin.fail:
        msg: >-
          Failed to apply managed policy {{ managed_allowed_policy_name }}.
          gcloud stderr: {{ apply_managed_policy.stderr | default('') }}
          If this is IAM_PERMISSION_DENIED, grant roles/orgpolicy.policyAdmin
          on an ancestor resource (organization or folder) that contains project {{ gcp_project }},
          then re-run with an account that has that inherited permission.
          Note: roles/orgpolicy.policyAdmin is not grantable directly on projects.
      when:
        - gcp_configure_managed_allowed_policy_members_enabled
        - apply_managed_policy.rc != 0

    - name: Managed policy setup summary
      ansible.builtin.debug:
        msg:
          - "Applied managed policy scope: {{ gcp_managed_policy_scope }}"
          - "Policy resource: {{ managed_allowed_policy_name }}"
          - "Allowed member subjects: {{ managed_allowed_member_subjects | join(', ') }}"
          - "Allowed principal sets: {{ managed_allowed_principal_sets | join(', ') }}"
      when: gcp_configure_managed_allowed_policy_members_enabled

    # ── 1. Pub/Sub topic ────────────────────────────────────────────────
    - name: Check if topic exists
      ansible.builtin.command:
        cmd: "gcloud pubsub topics describe {{ full_topic }} --project={{ gcp_project }} --format=value(name)"
      register: topic_check
      changed_when: false
      failed_when: false

    - name: Create Pub/Sub topic
      ansible.builtin.command:
        cmd: "gcloud pubsub topics create {{ topic_name }} --project={{ gcp_project }}"
      when: topic_check.rc != 0
      changed_when: true

    - name: Topic status
      ansible.builtin.debug:
        msg: "{{ 'Created' if topic_check.rc != 0 else 'Exists' }}: {{ full_topic }}"

    # ── 2. Gmail publish permission on topic ────────────────────────────
    - name: Check Gmail publisher IAM binding
      ansible.builtin.command:
        cmd: "gcloud pubsub topics get-iam-policy {{ full_topic }} --project={{ gcp_project }} --format=json"
      register: topic_iam_raw
      changed_when: false

    - name: Parse topic IAM policy
      ansible.builtin.set_fact:
        topic_has_gmail_publisher: >-
          {{
            (topic_iam_raw.stdout | from_json).get('bindings', [])
            | selectattr('role', 'equalto', 'roles/pubsub.publisher')
            | map(attribute='members')
            | flatten
            | select('equalto', gmail_publisher)
            | list
            | length > 0
          }}

    - name: Grant Gmail publisher role on topic
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub topics add-iam-policy-binding {{ full_topic }}
          --member={{ gmail_publisher }}
          --role=roles/pubsub.publisher
          --project={{ gcp_project }}
      register: grant_gmail_publisher
      when: not topic_has_gmail_publisher
      changed_when: true
      failed_when: false

    - name: Fail with actionable guidance when domain-restricted sharing blocks Gmail publisher
      ansible.builtin.fail:
        msg: >-
          Could not grant {{ gmail_publisher }} on {{ full_topic }}.
          gcloud stderr: {{ grant_gmail_publisher.stderr | default('') }}
          This is usually blocked by org policy `constraints/iam.allowedPolicyMemberDomains`.
          Gmail push requires this principal to publish to Pub/Sub.
          Ask an Org Policy Admin to migrate domain-restricted sharing to
          `iam.managed.allowedPolicyMembers` (or custom AllowPolicy) and allow
          `serviceAccount:gmail-api-push@system.gserviceaccount.com`.
      when:
        - not topic_has_gmail_publisher
        - grant_gmail_publisher.rc != 0

    # ── 3. Pub/Sub subscription ─────────────────────────────────────────
    - name: Check if subscription exists
      ansible.builtin.command:
        cmd: "gcloud pubsub subscriptions describe {{ full_sub }} --project={{ gcp_project }} --format=value(name)"
      register: sub_check
      changed_when: false
      failed_when: false

    - name: Create Pub/Sub subscription
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub subscriptions create {{ subscription_name }}
          --topic={{ topic_name }}
          --ack-deadline=30
          --project={{ gcp_project }}
      when: sub_check.rc != 0
      changed_when: true

    - name: Subscription status
      ansible.builtin.debug:
        msg: "{{ 'Created' if sub_check.rc != 0 else 'Exists' }}: {{ full_sub }}"

    # ── 4. Service account ──────────────────────────────────────────────
    - name: Check if service account exists
      ansible.builtin.command:
        cmd: "gcloud iam service-accounts describe {{ sa_email }} --project={{ gcp_project }} --format=value(email)"
      register: sa_check
      changed_when: false
      failed_when: false

    - name: Create service account
      ansible.builtin.command:
        cmd: >-
          gcloud iam service-accounts create {{ service_account_name }}
          --display-name="Gmail Push Subscriber"
          --project={{ gcp_project }}
      when: sa_check.rc != 0
      changed_when: true

    - name: Service account status
      ansible.builtin.debug:
        msg: "{{ 'Created' if sa_check.rc != 0 else 'Exists' }}: {{ sa_email }}"

    # ── 5. Subscriber permission on subscription ────────────────────────
    - name: Check subscriber IAM binding
      ansible.builtin.command:
        cmd: "gcloud pubsub subscriptions get-iam-policy {{ full_sub }} --project={{ gcp_project }} --format=json"
      register: sub_iam_raw
      changed_when: false

    - name: Parse subscription IAM policy
      ansible.builtin.set_fact:
        sub_has_subscriber: >-
          {{
            (sub_iam_raw.stdout | from_json).get('bindings', [])
            | selectattr('role', 'equalto', 'roles/pubsub.subscriber')
            | map(attribute='members')
            | flatten
            | select('equalto', sa_member)
            | list
            | length > 0
          }}

    - name: Grant subscriber role on subscription
      ansible.builtin.command:
        cmd: >-
          gcloud pubsub subscriptions add-iam-policy-binding {{ full_sub }}
          --member={{ sa_member }}
          --role=roles/pubsub.subscriber
          --project={{ gcp_project }}
      register: grant_subscriber_binding
      when: not sub_has_subscriber
      changed_when: true
      retries: 10
      delay: 3
      until: grant_subscriber_binding.rc == 0

    # ── 6. Service account key ──────────────────────────────────────────
    - name: Check if credentials file exists
      ansible.builtin.stat:
        path: "{{ credentials_dest }}"
      register: creds_file

    - name: Validate existing credentials file JSON
      ansible.builtin.command:
        cmd: >-
          python3 -c "import json,sys; d=json.load(open(sys.argv[1]));
          req=['type','project_id','private_key_id','private_key','client_email','client_id'];
          missing=[k for k in req if not d.get(k)];
          raise SystemExit(1 if missing else 0)" {{ credentials_dest }}
      register: creds_file_check
      changed_when: false
      failed_when: false
      when: creds_file.stat.exists

    - name: Determine whether credentials file is usable
      ansible.builtin.set_fact:
        creds_file_valid: "{{ (creds_file.stat.exists | bool) and ((creds_file_check.rc | default(1)) == 0) }}"

    - name: Remove invalid credentials file before regenerating
      ansible.builtin.file:
        path: "{{ credentials_dest }}"
        state: absent
      when:
        - creds_file.stat.exists
        - not creds_file_valid

    - name: Create service account key
      ansible.builtin.command:
        cmd: >-
          gcloud iam service-accounts keys create {{ credentials_dest }}
          --iam-account={{ sa_email }}
          --project={{ gcp_project }}
      when: not creds_file_valid
      changed_when: true

    - name: Protect credentials file
      ansible.builtin.file:
        path: "{{ credentials_dest }}"
        mode: "0600"

    # ── 7. Summary ──────────────────────────────────────────────────────
    - name: Print .env configuration
      ansible.builtin.debug:
        msg: |
          Add to .env:

          GMAIL_PUBSUB_PROJECT_ID={{ gcp_project }}
          GMAIL_PUBSUB_TOPIC={{ full_topic }}
          GMAIL_PUBSUB_SUBSCRIPTION={{ subscription_name }}
          GMAIL_PUBSUB_CREDENTIALS_FILE=tmp/{{ gcp_project }}-pubsub-sa.json
