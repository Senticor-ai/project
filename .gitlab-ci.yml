include:
  - template: Jobs/SAST.gitlab-ci.yml

default:
  tags:
    - large

stages:
  - quality
  - test
  - build
  - push
  - deploy

variables:
  # Pre-built CI image with Node 24 + Python 3.12 + Playwright + uv.
  # Rebuild on demand: glab ci run --variables BUILD_CI_IMAGE=true
  # Pushed to Harbor; runner authenticates via DOCKER_AUTH_CONFIG below.
  HARBOR_REGISTRY: harbor.100-114-108-51.nip.io:30443
  CI_NODE_PYTHON_IMAGE: ${HARBOR_REGISTRY}/terminandoyo/ci:latest
  # Docker pull auth for Harbor (allows runner to pull CI_NODE_PYTHON_IMAGE)
  DOCKER_AUTH_CONFIG: '{"auths":{"${HARBOR_REGISTRY}":{"username":"${HARBOR_USER}","password":"${HARBOR_PASSWORD}"}}}'
  # Cache directories (must be inside $CI_PROJECT_DIR for GitLab cache)
  npm_config_cache: '$CI_PROJECT_DIR/.npm-cache'

.default-rules:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

.backend-postgres:
  services:
    - name: postgres:16
      alias: postgres
  variables:
    POSTGRES_USER: terminandoyo
    POSTGRES_PASSWORD: ci_test_password
    POSTGRES_DB: terminandoyo
    DATABASE_URL: "postgresql://terminandoyo:ci_test_password@postgres:5432/terminandoyo"
    VITE_API_BASE_URL: "http://localhost:8000"
    FUSEKI_ENABLED: "false"
    MEILI_URL: ""

.failure-issue:
  after_script:
    - chmod +x ci/handle-failure-issue.sh && ci/handle-failure-issue.sh

# --- Caching templates ---

.frontend-cache:
  cache:
    - key:
        files: [frontend/package-lock.json]
      paths: [.npm-cache/]

.backend-cache:
  cache:
    - key:
        files: [backend/uv.lock]
      paths: [backend/.venv/]

.fullstack-cache:
  cache:
    - key:
        files: [frontend/package-lock.json]
      paths: [.npm-cache/]
    - key:
        files: [backend/uv.lock]
      paths: [backend/.venv/]

# ==================== CI IMAGE (on-demand only: run with BUILD_CI_IMAGE=true) ====================

build-ci-image:
  stage: quality
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  before_script:
    - mkdir -p /kaniko/.docker
    - AUTH_B64="$(printf '%s:%s' "$HARBOR_USER" "$HARBOR_PASSWORD" | base64 | tr -d '\n')"
    - printf '{"auths":{"%s":{"auth":"%s"}}}\n' "$HARBOR_REGISTRY" "$AUTH_B64" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR/ci" --dockerfile "$CI_PROJECT_DIR/ci/Dockerfile.ci" --destination "${HARBOR_REGISTRY}/terminandoyo/ci:latest" --insecure --skip-tls-verify
  rules:
    - if: $BUILD_CI_IMAGE == "true"

# ==================== QUALITY ====================

frontend-lint:
  stage: quality
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - npm run lint

frontend-typecheck:
  stage: quality
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - npm run type-check

backend-lint:
  stage: quality
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run ruff check .

backend-typecheck:
  stage: quality
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run mypy app/

# ==================== TEST (DAG: starts immediately, no wait for quality) ====================

frontend-unit:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - CI=1 npx vitest run --project=unit --coverage --coverage.reporter=text --coverage.reporter=cobertura --coverage.reporter=json-summary --coverage.reportsDirectory=coverage/unit
  artifacts:
    when: always
    paths:
      - frontend/coverage/unit/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/unit/cobertura-coverage.xml
  coverage: '/All files[^|]*\|[^|]*\s([0-9]+(?:\.[0-9]+)?)\s/'

backend-unit:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run pytest -q --maxfail=1 --cov=app --cov-report=term-missing --cov-report=xml:coverage/unit.xml --cov-report=html:coverage/unit -k "not integration and not playwright"
  artifacts:
    when: always
    paths:
      - backend/coverage/unit/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/unit.xml
  coverage: '/TOTAL.*\s+([0-9]+%)$/'

backend-integration:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run pytest -q --maxfail=1 --cov=app --cov-report=term-missing --cov-report=xml:coverage/integration.xml --cov-report=html:coverage/integration -k "integration and not playwright"
  artifacts:
    when: always
    paths:
      - backend/coverage/integration/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/integration.xml
  coverage: '/TOTAL.*\s+([0-9]+%)$/'

frontend-integration:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .fullstack-cache]
  before_script:
    - cd $CI_PROJECT_DIR/backend && uv sync --quiet --all-groups --all-extras
    - cd $CI_PROJECT_DIR/frontend && npm ci --ignore-scripts --silent
  script:
    - cd $CI_PROJECT_DIR/backend && uv run python -m app.db_init
    - cd $CI_PROJECT_DIR/backend && uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    - |
      BACKEND_READY=0
      for i in $(seq 1 30); do
        if curl -sf http://localhost:8000/schemas > /dev/null 2>&1; then
          echo "Backend is ready"
          BACKEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$BACKEND_READY" -ne 1 ]; then
        echo "Backend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && CI=1 npx vitest run --project=unit -t "JSON Schema contract"

frontend-storybook:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --silent
  script:
    - STORYBOOK_TESTS=1 CI=1 npx vitest run --project=storybook

backend-e2e:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run python -m app.db_init
    - uv run pytest -q tests/test_flow_playwright.py

frontend-e2e:
  stage: test
  needs: []
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .fullstack-cache]
  before_script:
    - cd $CI_PROJECT_DIR/backend && uv sync --quiet --all-groups --all-extras
    - cd $CI_PROJECT_DIR/frontend && npm ci --ignore-scripts --silent
  script:
    - cd $CI_PROJECT_DIR/backend && uv run python -m app.db_init
    - cd $CI_PROJECT_DIR/backend && uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    - |
      BACKEND_READY=0
      for i in $(seq 1 30); do
        if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
          echo "Backend is ready"
          BACKEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$BACKEND_READY" -ne 1 ]; then
        echo "Backend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && npm run dev -- --host 0.0.0.0 --port 5173 &
    - |
      FRONTEND_READY=0
      for i in $(seq 1 60); do
        if curl -sf http://localhost:5173 > /dev/null 2>&1; then
          echo "Frontend is ready"
          FRONTEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$FRONTEND_READY" -ne 1 ]; then
        echo "Frontend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && CI=1 npm run test:e2e
  artifacts:
    when: always
    paths:
      - frontend/playwright-report/
      - frontend/test-results/

# ==================== BUILD (parallel frontend + backend + storybook, starts immediately) ====================

.build-base:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  extends: .default-rules

build-frontend:
  extends: .build-base
  needs: []
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile" --no-push --tarPath /tmp/frontend.tar
  artifacts:
    paths: [/tmp/frontend.tar]
    expire_in: 1 hour

build-backend:
  extends: .build-base
  needs: []
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/backend/Dockerfile" --no-push --tarPath /tmp/backend.tar
  artifacts:
    paths: [/tmp/backend.tar]
    expire_in: 1 hour

build-storybook:
  extends: .build-base
  needs: []
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile.storybook" --build-arg STORYBOOK_BASE=/storybook/ --no-push --tarPath /tmp/storybook.tar
  artifacts:
    paths: [/tmp/storybook.tar]
    expire_in: 1 hour

# ==================== PUSH (parallel frontend + backend + storybook) ====================

.push-base:
  stage: push
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  before_script:
    - mkdir -p /kaniko/.docker
    - AUTH_B64="$(printf '%s:%s' "$HARBOR_USER" "$HARBOR_PASSWORD" | base64 | tr -d '\n')"
    - printf '{"auths":{"%s":{"auth":"%s"}}}\n' "$HARBOR_REGISTRY" "$AUTH_B64" > /kaniko/.docker/config.json
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

push-frontend:
  extends: .push-base
  needs: [build-frontend]
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile" --destination "${HARBOR_REGISTRY}/terminandoyo/frontend:${IMAGE_TAG}" --insecure --skip-tls-verify

push-backend:
  extends: .push-base
  needs: [build-backend]
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/backend/Dockerfile" --destination "${HARBOR_REGISTRY}/terminandoyo/backend:${IMAGE_TAG}" --insecure --skip-tls-verify

push-storybook:
  extends: .push-base
  needs: [build-storybook]
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile.storybook" --build-arg STORYBOOK_BASE=/storybook/ --destination "${HARBOR_REGISTRY}/terminandoyo/storybook:${IMAGE_TAG}" --insecure --skip-tls-verify

# ==================== DEPLOY ====================

update-manifests:
  stage: deploy
  image: alpine:3.20
  needs: [push-frontend, push-backend, push-storybook]
  before_script:
    - apk add --no-cache git sed
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      KUST="infra/k8s/overlays/production/kustomization.yaml"
      echo "Updating kustomization to registry: ${HARBOR_REGISTRY}, tag: ${IMAGE_TAG}"
      sed -i "s|newName: .*/backend|newName: ${HARBOR_REGISTRY}/terminandoyo/backend|" "$KUST"
      sed -i "s|newName: .*/frontend|newName: ${HARBOR_REGISTRY}/terminandoyo/frontend|" "$KUST"
      sed -i "s|newName: .*/storybook|newName: ${HARBOR_REGISTRY}/terminandoyo/storybook|" "$KUST"
      sed -i "s/newTag: .*/newTag: \"${IMAGE_TAG}\"/" "$KUST"
      cat "$KUST"
      git config user.email "ci@terminandoyo.dev"
      git config user.name "GitLab CI"
      git config http.sslVerify false
      echo "Clone URL from runner: $(git remote get-url origin)"
      CLONE_URL=$(git remote get-url origin | sed "s|://[^@]*@|://gitlab-ci-token:${CI_JOB_TOKEN}@|")
      git remote set-url origin "$CLONE_URL"
      echo "Push URL: $(git remote get-url origin | sed 's|://[^@]*@|://***@|')"
      git add "$KUST"
      git commit -m "deploy: update image tag to ${IMAGE_TAG} [skip ci]"
      git push origin HEAD:main
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
