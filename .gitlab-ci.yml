include:
  - template: Jobs/SAST.gitlab-ci.yml

default:
  tags:
    - large

stages:
  - quality
  - test
  - build
  - push
  - deploy

variables:
  # Pre-built CI image with Node 24 + Python 3.12 + Playwright + uv.
  # Auto-built by build-ci-image job when ci/Dockerfile.ci changes.
  # Uses GitLab container registry â€” runners authenticate automatically via CI_JOB_TOKEN.
  CI_NODE_PYTHON_IMAGE: ${CI_REGISTRY_IMAGE}/ci:latest
  # Cache directories (must be inside $CI_PROJECT_DIR for GitLab cache)
  npm_config_cache: '$CI_PROJECT_DIR/.npm-cache'

.default-rules:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

.backend-postgres:
  services:
    - name: postgres:16
      alias: postgres
  variables:
    POSTGRES_USER: terminandoyo
    POSTGRES_PASSWORD: ci_test_password
    POSTGRES_DB: terminandoyo
    DATABASE_URL: "postgresql://terminandoyo:ci_test_password@postgres:5432/terminandoyo"
    VITE_API_BASE_URL: "http://localhost:8000"
    FUSEKI_ENABLED: "false"
    MEILI_URL: ""

.failure-issue:
  after_script:
    - chmod +x ci/handle-failure-issue.sh && ci/handle-failure-issue.sh

# --- Caching templates ---

.frontend-cache:
  cache:
    - key:
        files: [frontend/package-lock.json]
      paths: [.npm-cache/]

.backend-cache:
  cache:
    - key:
        files: [backend/uv.lock]
      paths: [backend/.venv/]

.fullstack-cache:
  cache:
    - key:
        files: [frontend/package-lock.json]
      paths: [.npm-cache/]
    - key:
        files: [backend/uv.lock]
      paths: [backend/.venv/]

# ==================== CI IMAGE (auto-build when Dockerfile changes) ====================

build-ci-image:
  stage: quality
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  before_script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf '%s:%s' "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR/ci" --dockerfile "$CI_PROJECT_DIR/ci/Dockerfile.ci" --destination "${CI_REGISTRY_IMAGE}/ci:latest" --insecure --skip-tls-verify
  rules:
    - changes: [ci/Dockerfile.ci]

# ==================== QUALITY ====================

frontend-lint:
  stage: quality
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - npm run lint

frontend-typecheck:
  stage: quality
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - npm run type-check

backend-lint:
  stage: quality
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run ruff check .

backend-typecheck:
  stage: quality
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run mypy app/

# ==================== TEST (DAG: starts immediately, no wait for quality) ====================

frontend-unit:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --ignore-scripts --silent
  script:
    - CI=1 npx vitest run --project=unit --coverage --coverage.reporter=text --coverage.reporter=cobertura --coverage.reporter=json-summary --coverage.reportsDirectory=coverage/unit
  artifacts:
    when: always
    paths:
      - frontend/coverage/unit/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/unit/cobertura-coverage.xml
  coverage: '/All files[^|]*\|[^|]*\s([0-9]+(?:\.[0-9]+)?)\s/'

backend-unit:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run pytest -q --maxfail=1 --cov=app --cov-report=term-missing --cov-report=xml:coverage/unit.xml --cov-report=html:coverage/unit -k "not integration and not playwright"
  artifacts:
    when: always
    paths:
      - backend/coverage/unit/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/unit.xml
  coverage: '/TOTAL.*\s+([0-9]+%)$/'

backend-integration:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run pytest -q --maxfail=1 --cov=app --cov-report=term-missing --cov-report=xml:coverage/integration.xml --cov-report=html:coverage/integration -k "integration and not playwright"
  artifacts:
    when: always
    paths:
      - backend/coverage/integration/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage/integration.xml
  coverage: '/TOTAL.*\s+([0-9]+%)$/'

frontend-integration:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .fullstack-cache]
  before_script:
    - cd $CI_PROJECT_DIR/backend && uv sync --quiet --all-groups --all-extras
    - cd $CI_PROJECT_DIR/frontend && npm ci --ignore-scripts --silent
  script:
    - cd $CI_PROJECT_DIR/backend && uv run python -m app.db_init
    - cd $CI_PROJECT_DIR/backend && uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    - |
      BACKEND_READY=0
      for i in $(seq 1 30); do
        if curl -sf http://localhost:8000/schemas > /dev/null 2>&1; then
          echo "Backend is ready"
          BACKEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$BACKEND_READY" -ne 1 ]; then
        echo "Backend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && CI=1 npx vitest run --project=unit -t "JSON Schema contract"

frontend-storybook:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .failure-issue, .frontend-cache]
  before_script:
    - cd frontend && npm ci --silent
  script:
    - STORYBOOK_TESTS=1 CI=1 npx vitest run --project=storybook

backend-e2e:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .backend-cache]
  before_script:
    - cd backend && uv sync --quiet --all-groups --all-extras
  script:
    - uv run python -m app.db_init
    - uv run pytest -q tests/test_flow_playwright.py

frontend-e2e:
  stage: test
  needs:
    - job: build-ci-image
      optional: true
  allow_failure: true
  image: $CI_NODE_PYTHON_IMAGE
  extends: [.default-rules, .backend-postgres, .failure-issue, .fullstack-cache]
  before_script:
    - cd $CI_PROJECT_DIR/backend && uv sync --quiet --all-groups --all-extras
    - cd $CI_PROJECT_DIR/frontend && npm ci --ignore-scripts --silent
  script:
    - cd $CI_PROJECT_DIR/backend && uv run python -m app.db_init
    - cd $CI_PROJECT_DIR/backend && uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 &
    - |
      BACKEND_READY=0
      for i in $(seq 1 30); do
        if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
          echo "Backend is ready"
          BACKEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$BACKEND_READY" -ne 1 ]; then
        echo "Backend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && npm run dev -- --host 0.0.0.0 --port 5173 &
    - |
      FRONTEND_READY=0
      for i in $(seq 1 60); do
        if curl -sf http://localhost:5173 > /dev/null 2>&1; then
          echo "Frontend is ready"
          FRONTEND_READY=1
          break
        fi
        sleep 1
      done
      if [ "$FRONTEND_READY" -ne 1 ]; then
        echo "Frontend failed to become ready"
        exit 1
      fi
    - cd $CI_PROJECT_DIR/frontend && CI=1 npm run test:e2e
  artifacts:
    when: always
    paths:
      - frontend/playwright-report/
      - frontend/test-results/

# ==================== BUILD (parallel frontend + backend, starts immediately) ====================

.build-base:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  extends: .default-rules

build-frontend:
  extends: .build-base
  needs: []
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile" --no-push --tarPath /tmp/frontend.tar
  artifacts:
    paths: [/tmp/frontend.tar]
    expire_in: 1 hour

build-backend:
  extends: .build-base
  needs: []
  script:
    - /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/backend/Dockerfile" --no-push --tarPath /tmp/backend.tar
  artifacts:
    paths: [/tmp/backend.tar]
    expire_in: 1 hour

# ==================== PUSH (parallel frontend + backend) ====================

.push-base:
  stage: push
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  before_script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf '%s:%s' "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

push-frontend:
  extends: .push-base
  needs: [build-frontend]
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/frontend/Dockerfile" --destination "${CI_REGISTRY_IMAGE}/frontend:${IMAGE_TAG}" --insecure --skip-tls-verify

push-backend:
  extends: .push-base
  needs: [build-backend]
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      /kaniko/executor --context "$CI_PROJECT_DIR" --dockerfile "$CI_PROJECT_DIR/backend/Dockerfile" --destination "${CI_REGISTRY_IMAGE}/backend:${IMAGE_TAG}" --insecure --skip-tls-verify

# ==================== DEPLOY ====================

update-manifests:
  stage: deploy
  image: alpine:3.20
  needs: [push-frontend, push-backend]
  before_script:
    - apk add --no-cache git sed
  script:
    - |
      IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      KUST="infra/k8s/overlays/production/kustomization.yaml"
      echo "Updating kustomization to registry: ${CI_REGISTRY_IMAGE}, tag: ${IMAGE_TAG}"
      sed -i "s|newName: .*/backend|newName: ${CI_REGISTRY_IMAGE}/backend|" "$KUST"
      sed -i "s|newName: .*/frontend|newName: ${CI_REGISTRY_IMAGE}/frontend|" "$KUST"
      sed -i "s/newTag: .*/newTag: \"${IMAGE_TAG}\"/" "$KUST"
      cat "$KUST"
      git config user.email "ci@terminandoyo.dev"
      git config user.name "GitLab CI"
      git config http.sslVerify false
      echo "Clone URL from runner: $(git remote get-url origin)"
      CLONE_URL=$(git remote get-url origin | sed "s|://[^@]*@|://gitlab-ci-token:${CI_JOB_TOKEN}@|")
      git remote set-url origin "$CLONE_URL"
      echo "Push URL: $(git remote get-url origin | sed 's|://[^@]*@|://***@|')"
      git add "$KUST"
      git commit -m "deploy: update image tag to ${IMAGE_TAG} [skip ci]"
      git push origin HEAD:main
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
